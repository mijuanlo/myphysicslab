<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>myphysicslab.lab.engine2D.ContactSim</title><link href="dossier.css" rel="stylesheet" type="text/css"><script src="types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,[[[&quot;myphysicslab.lab.engine2D.ContactSim&quot;,null,null,null,[null,258,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],null,[[[null,&quot;&lt;p&gt;Physics engine for rigid bodies with contact forces to allow resting contact. The\ncontact forces prevent the bodies from interpenetrating when they are in resting\ncontact. Resting contact means the bodies are not colliding, but have edges and corners\nthat are in continuous contact and exerting force on each other.&lt;/p&gt;\n&lt;p&gt;The overall idea is to calculate the exact amount of force needed to &lt;em&gt;just barely&lt;/em&gt;\nprevent the objects from penetrating. These contact forces are calculated in the\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#evaluate\&quot;&gt;&lt;code&gt;#evaluate&lt;/code&gt;&lt;/a&gt; method, which is called by the\n&lt;code&gt;myphysicslab.lab.model.DiffEqSolver&lt;/code&gt; at\nthe request of the &lt;code&gt;myphysicslab.lab.model.AdvanceStrategy&lt;/code&gt; to advance the state\nof the simulation.&lt;/p&gt;\n&lt;h3&gt;Parameters Created&lt;/h3&gt;\n&lt;ul&gt;&lt;li&gt;ParameterString named &lt;code&gt;EXTRA_ACCEL&lt;/code&gt;, see &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#setExtraAccel\&quot;&gt;&lt;code&gt;#setExtraAccel&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;See also the super class for additional Parameters.&lt;/p&gt;\n&lt;h3&gt;Background and References&lt;/h3&gt;\n&lt;p&gt;See explanations at:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;&lt;a href=\&quot;Engine2D.html\&quot;&gt;2D Physics Engine Overview&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;The math and physics underlying\n&lt;a href=\&quot;http://www.myphysicslab.com/engine2D/rigid-body-en.html\&quot;&gt;RigidBodySim&lt;/a&gt;,\n&lt;a href=\&quot;http://www.myphysicslab.com/engine2D/collision-en.html\&quot;&gt;ImpulseSim&lt;/a&gt; and\n&lt;a href=\&quot;http://www.myphysicslab.com/engine2D/contact-en.html\&quot;&gt;ContactSim&lt;/a&gt; are\ndescribed on the myPhysicsLab website.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;a href=\&quot;ContactSim_Math.html\&quot;&gt;ContactSim Math&lt;/a&gt;  has more details about the math.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;The algorithm used here is based on these papers:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;David Baraff, &lt;a href=\&quot;Baraff_Fast_Contact_Force_94.pdf\&quot;&gt;Fast Contact Force Computation for Nonpenetrating Rigid Bodies.&lt;/a&gt;\nComputer Graphics Proceedings, Annual Conference Series, 1994; pages 23-34.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;David Baraff, &lt;a href=\&quot;Baraff_Siggraph_97_Course_Notes.pdf\&quot;&gt;An Introduction to Physically Based Modeling: Rigid Body Simulation II—Nonpenetration Constraints.&lt;/a&gt;\nSiggraph &amp;#39;97 Course Notes.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;See also the &lt;a href=\&quot;http://www-2.cs.cmu.edu/~baraff/papers/index.html\&quot;&gt;list of David Baraff&amp;#39;s papers&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;See the paper &lt;a href=\&quot;CEP_Curved_Edge_Physics.pdf\&quot;&gt;Curved Edge Physics paper&lt;/a&gt; by Erik Neumann\nfor modifications to contact forces when curved edges are involved.&lt;/p&gt;\n&lt;h3&gt;Find External Forces&lt;/h3&gt;\n&lt;p&gt;Within &lt;code&gt;evaluate()&lt;/code&gt; we first let the super-class apply the external forces to the\nRigidBody objects. The external forces include things like gravity, thrust, springs,\ndamping. The external forces result in accelerations of the bodies, so at this point\nmany of the bodies would start to penetrate into each other if we did not find contact\nforces to prevent that.&lt;/p&gt;\n&lt;h3&gt;Find Contacts&lt;/h3&gt;\n&lt;p&gt;Next in &lt;code&gt;evaluate()&lt;/code&gt; we call &lt;code&gt;findCollisions()&lt;/code&gt; to find all the contact points, and\npossibly collisions as well. If we find any actual (penetrating) collisions, then\n&lt;code&gt;evaluate()&lt;/code&gt; returns the set of collisions found, which should then be handled before\ntrying to step forward again, see &lt;a href=\&quot;myphysicslab.lab.engine2D.ImpulseSim.html\&quot;&gt;&lt;code&gt;ImpulseSim&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;The criteria for finding a contact is:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;the corner (or edge) of one body must be &lt;em&gt;very close&lt;/em&gt; to the edge of the other body,\nas specified by &lt;code&gt;getDistanceTol()&lt;/code&gt;.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;the bodies must be &lt;em&gt;moving very slowly&lt;/em&gt; relative to each other (the normal velocity)\nat the contact point, as specified by &lt;code&gt;getVelocityTol()&lt;/code&gt;.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;The &lt;code&gt;evaluate()&lt;/code&gt; method optionally finds independent subsets of collisions, because that\ncan make the compute_forces algorithm, which is &lt;code&gt;O(n^4)&lt;/code&gt;, run faster in some cases. See\nthe flag &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#module$exports$myphysicslab$lab$engine2D$ContactSim.SUBSET_COLLISIONS\&quot;&gt;&lt;code&gt;#SUBSET_COLLISIONS&lt;/code&gt;&lt;/a&gt;. Collisions are independent when there is no chain\nof moveable (finite mass) bodies in common between the collisions.&lt;/p&gt;\n&lt;h3&gt;The Matrix Equation for Contact Forces&lt;/h3&gt;\n&lt;p&gt;Now we have the set of contacts and we know the accelerations of the bodies due to\nexternal forces. We set up a matrix equation&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a &amp;#61; A f &amp;#43; b\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;where&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;&lt;code&gt;a &amp;#61;&lt;/code&gt; vector of accelerations&lt;/li&gt;&lt;li&gt;&lt;code&gt;A &amp;#61;&lt;/code&gt; matrix describing how the &lt;code&gt;j&lt;/code&gt;-th contact force affects the acceleration of\nthe &lt;code&gt;i&lt;/code&gt;-th &lt;em&gt;contact distance&lt;/em&gt; (the separation between the bodies)&lt;/li&gt;&lt;li&gt;&lt;code&gt;f &amp;#61;&lt;/code&gt; vector of contact forces (to be found)&lt;/li&gt;&lt;li&gt;&lt;code&gt;b &amp;#61;&lt;/code&gt; external forces (gravity, thrust, rubber band, damping)&lt;/li&gt;&lt;/ul&gt;\n&lt;h3&gt;Set Up the A Matrix&lt;/h3&gt;\n&lt;p&gt;Here is how to set up the &lt;code&gt;A&lt;/code&gt; matrix: For each contact distance &lt;code&gt;d_i&lt;/code&gt;, find how the\nacceleration of that contact distance &lt;code&gt;d_i&amp;#39;&amp;#39;&lt;/code&gt; is related to the force at the &lt;code&gt;j&lt;/code&gt;-th\ncontact point. The force at the &lt;code&gt;j&lt;/code&gt;-th contact point is &lt;code&gt;f_j N_j&lt;/code&gt;, where &lt;code&gt;f_j&lt;/code&gt; is a\nscalar and &lt;code&gt;N_j&lt;/code&gt; is the vector normal. The &lt;code&gt;a_ij&lt;/code&gt; entry in the &lt;code&gt;A&lt;/code&gt; matrix tells what\nthat relationship is between &lt;code&gt;f_j&lt;/code&gt; and &lt;code&gt;d_i&amp;#39;&amp;#39;&lt;/code&gt;. This &lt;code&gt;a_ij&lt;/code&gt; value is dependent only on\nthe current geometry of how the objects are oriented and touching each other.&lt;/p&gt;\n&lt;img src=\&quot;Baraff_Figure26.png\&quot; alt=\&quot;Baraff Figure 26\&quot; /&gt;\n&lt;p&gt;For example, consider Figure 26 of\n&lt;a href=\&quot;Baraff_Siggraph_97_Course_Notes.pdf\&quot;&gt;Baraffs Siggraph 97 Course Notes&lt;/a&gt;\nshown above. The figure shows two bodies\n(B,C) resting on the ground, and a third body (A) resting on top of the other two. There\nare 5 points of contact among the bodies and the ground. Here is how the matrix\nequation would look for this situation:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a1     a11  a12  a13   0    0     f1     b1\na2     a21  a22  a23   0    0     f2     b2\na3  &amp;#61;  a31  a32  a33  a34   0  *  f3  &amp;#43;  b3\na4      0    0   a43  a44  a45    f4     b4\na5      0    0    0   a54  a55    f5     b5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Consider the first contact at &lt;code&gt;p1&lt;/code&gt; which is between the ground and body B. The\nacceleration of the contact distance at &lt;code&gt;p1&lt;/code&gt; is affected by the forces at &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;p2&lt;/code&gt;,\nand &lt;code&gt;p3&lt;/code&gt; because all of those forces affect the movement of body B. But the forces at\n&lt;code&gt;p4&lt;/code&gt; and &lt;code&gt;p5&lt;/code&gt; have no effect, so their entries are zero in the first row of the &lt;code&gt;A&lt;/code&gt;\nmatrix.&lt;/p&gt;\n&lt;p&gt;The first row of the matrix equation can be written out as&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a1 &amp;#61; a11*f1 &amp;#43; a12*f2 &amp;#43; a13*f3 &amp;#43; 0*f4 &amp;#43; 0*f5 &amp;#43; b1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That equation says the acceleration of contact distance at point &lt;code&gt;p1&lt;/code&gt; is equal to a\ncertain linear combination of the contact forces &lt;code&gt;f1&lt;/code&gt;, &lt;code&gt;f2&lt;/code&gt;, &lt;code&gt;f3&lt;/code&gt;, plus the acceleration\ndue to the external forces which is &lt;code&gt;b1&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;The particular values for &lt;code&gt;a11, a12, a13&lt;/code&gt; are dependent on the geometry of the\nsituation: where the forces &lt;code&gt;f1&lt;/code&gt;, &lt;code&gt;f2&lt;/code&gt;, &lt;code&gt;f3&lt;/code&gt; are applied on the body; in what direction\ndo the forces act; where is the center of mass of the body; how the force causes the\nbody to accelerate and spin; where is the point &lt;code&gt;p1&lt;/code&gt; is in relation to the center of\nmass; etc.&lt;/p&gt;\n&lt;p&gt;The third contact at &lt;code&gt;p3&lt;/code&gt; is more complicated because it is affected by any forces\nacting on body A or body B. These include all the forces except &lt;code&gt;f5&lt;/code&gt;. Therefore the\nthird row of the &lt;code&gt;A&lt;/code&gt; matrix has four non-zero entries corresponding to the four forces\nthat affect the acceleration at &lt;code&gt;p3&lt;/code&gt;.&lt;/p&gt;\n&lt;h3&gt;Constraints On the Solution&lt;/h3&gt;\n&lt;p&gt;Assume we now have the &lt;code&gt;b&lt;/code&gt; vector of external forces and the &lt;code&gt;A&lt;/code&gt; matrix of dependencies\nbetween contact forces and resulting accelerations of different bodies. We solve for the\n&lt;code&gt;f&lt;/code&gt; vector of contact forces subject to the following constraints:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a &amp;gt;&amp;#61; 0\nf &amp;gt;&amp;#61; 0\na.f &amp;#61; 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The constraints in words are:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a &amp;gt;&amp;#61; 0&lt;/code&gt;  we require all the relative normal accelerations (between bodies\nat contact points) to be either zero (remain in contact) or positive (separating).&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;f &amp;gt;&amp;#61; 0&lt;/code&gt;  We require contact forces to be zero or positive because they can\nonly push, not pull.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a.f &amp;#61; 0&lt;/code&gt;  The third constraint is a math way of saying that\nif there is a force, then acceleration is zero OR\nif there is acceleration (separation), then there is no force.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;Note that for Joints the constraints are different:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a &amp;#61;&amp;#61; 0&lt;/code&gt;  a Joint always remains in resting contact, it never separates&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;No constraint on &lt;code&gt;f&lt;/code&gt; because it can push or pull.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;h3&gt;Solving For the Contact Forces&lt;/h3&gt;\n&lt;p&gt;The &lt;a href=\&quot;Baraff_Fast_Contact_Force_94.pdf\&quot;&gt;Baraff &amp;#39;Fast Contact Force&amp;#39; paper&lt;/a&gt; goes into full\ndetail about the algorithm to solve this constraint problem.  Here is a quick summary:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;Start by setting all the forces to zero&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;Add in one force at a time, just enough to maintain the constraints on the points that\nhave been considered so far (ignoring the others), and readjust the other forces as\nnecessary.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;Continue adding one force at a time, ignoring points that haven&amp;#39;t been considered yet.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;Suppose that we are working on adding in the third force after already finding the\nforces for points 1 and 2. The trick is that we only look at the constraints on the\nfirst 3 contact points, we ignore the other contact points and other forces. Once we&amp;#39;ve\nfound the 3rd force (and rebalanced forces 1 and 2 as needed) we then move on to\nconsider the 4th force.&lt;/p&gt;\n&lt;p&gt;The last step is to &lt;strong&gt;apply the contact forces&lt;/strong&gt; to the bodies, which gives the final\nset of accelerations that the &lt;code&gt;evaluate()&lt;/code&gt; method then returns to the differential\nequation solver.&lt;/p&gt;\n&lt;h3&gt;Extra Acceleration&lt;/h3&gt;\n&lt;p&gt;The contact forces are calculated so that there is zero acceleration at contact points; but this does not immediately affect the remaining small velocity at a contact point.  As a result, objects that are in resting contact will often have some undesirable jittery motion.&lt;/p&gt;\n&lt;p&gt;One way to deal with this is to request a small amount of additional acceleration which will eliminate that velocity over a few time steps.  If the objects are moving towards each other (a small negative velocity) we request a little more acceleration which leads to a little more force being applied there.  If the objects are moving apart (a small positive velocity) we request a little less acceleration.&lt;/p&gt;\n&lt;p&gt;The extra acceleration is added to the &lt;code&gt;b&lt;/code&gt; vector in the private method\n&lt;code&gt;calculate_b_vector&lt;/code&gt;. See &lt;a href=\&quot;myphysicslab.lab.engine2D.ExtraAccel.html\&quot;&gt;&lt;code&gt;ExtraAccel&lt;/code&gt;&lt;/a&gt; enum for\nexplanations of the various options. See &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#setExtraAccel\&quot;&gt;&lt;code&gt;#setExtraAccel&lt;/code&gt;&lt;/a&gt; for how to specify the\ndesired ExtraAccel option.&lt;/p&gt;\n&lt;h3&gt;Intermediate Steps During &lt;code&gt;evaluate&lt;/code&gt;&lt;/h3&gt;\n&lt;p&gt;A DiffEqSolver works by &amp;#39;averaging&amp;#39; several calculated states for each time step; for\nexample ModifiedEuler averages 2 states, and RungeKutta averages 4 states. The collision\ndetection done in &lt;code&gt;evaluate()&lt;/code&gt; is based on those intermediate states within a step of\nthe DiffEqSolver, so it is arguable whether that state actually ever occurs.&lt;/p&gt;\n&lt;p&gt;This point of view argues for only using the collisions detected between full steps of\nthe DiffEqSolver. However, contacts can come and go during these sub-steps so it seems\nin practice to be more accurate to find the set of contacts anew in each call to\n&lt;code&gt;evaluate()&lt;/code&gt;. Also if a penetrating collision is detected we need to stop the process\nand handle that collision instead, so it is important to do collision detection for that\nas well.&lt;/p&gt;\n&lt;p&gt;Prior to February 2012, there was an experimental option specified by the flag\n&lt;code&gt;REUSE_COLLISIONS&lt;/code&gt; for which we did &lt;em&gt;not&lt;/em&gt; find the collisions anew in the &lt;code&gt;evaluate()&lt;/code&gt;\nmethod, instead we used the collisions found outside the &lt;code&gt;evaluate()&lt;/code&gt; method during\n&lt;code&gt;AdvanceStrategy.advance()&lt;/code&gt; which are based on a complete ODE step. See the git archive.&lt;/p&gt;\n&quot;]]],[null,null,null,null,null,1],null,[],null,[],[[[&quot;COLLISIONS_DISABLED&quot;,[null,1451,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;For debugging, this allows code to look for collisions, but does not actually\nreturn them. This allows to debug code for finding nearest point between objects.&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[],[null,1]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;ELASTICITY_SET&quot;,[null,783,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Name of event broadcast from &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#setElasticity\&quot;&gt;&lt;code&gt;#setElasticity&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[[&quot;SHOW_CONTACTS&quot;,[null,1245,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;write to debug console detail on all contacts found&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;SHOW_NUM_CONTACTS&quot;,[null,1250,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;SUBSET_COLLISIONS&quot;,[null,1239,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Find subsets of related contacts to solve each subset separately for contact forces.\nThis feature is useful for cases where there are a lot of contacts that are in separate\ngroups (two piles) because the matrices being solved are smaller. The ComputeForces\nalgorithm is &lt;code&gt;O(n^4)&lt;/code&gt;. For example suppose there are 40 contact points. The cost of\n&lt;code&gt;40^4 &amp;#61; 2,560,000&lt;/code&gt; is far greater than &lt;code&gt;20^4 &amp;#43; 20^4 &amp;#61; 320,000&lt;/code&gt;. There is some overhead\nto finding the subsets, so this can lose time when there is just a big single pile.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;VW_&quot;,[null,778,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Offset in the VarsList for a RigidBody&amp;#39;s angular velocity&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;VX_&quot;,[null,758,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Offset in the VarsList for a RigidBody&amp;#39;s x velocity&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;VY_&quot;,[null,768,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Offset in the VarsList for a RigidBody&amp;#39;s y velocity&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;W_&quot;,[null,773,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Offset in the VarsList for a RigidBody&amp;#39;s angle&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;X_&quot;,[null,753,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Offset in the VarsList for a RigidBody&amp;#39;s x position&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;Y_&quot;,[null,763,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Offset in the VarsList for a RigidBody&amp;#39;s y position&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;en&quot;,[null,802,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[]],null,null,null,null,null,[],[]],[null,null,null,null,[[[&quot;COLLISION_ACCURACY&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[&quot;COLLISION_HANDLING&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[&quot;DISTANCE_TOL&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[&quot;EXTRA_ACCEL&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[&quot;RANDOM_SEED&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[&quot;SHOW_COLLISIONS&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[&quot;SHOW_FORCES&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[&quot;VELOCITY_TOL&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]]]]]]],[[&quot;superClass_&quot;,[null,262,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[]],null,null,null,null,null,[],[]],[null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim.prototype&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html&quot;]],null,[]]]]],[[&quot;ContactSim&quot;,[null,258,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Physics engine for rigid bodies with contact forces to allow resting contact. The\ncontact forces prevent the bodies from interpenetrating when they are in resting\ncontact. Resting contact means the bodies are not colliding, but have edges and corners\nthat are in continuous contact and exerting force on each other.&lt;/p&gt;\n&lt;p&gt;The overall idea is to calculate the exact amount of force needed to &lt;em&gt;just barely&lt;/em&gt;\nprevent the objects from penetrating. These contact forces are calculated in the\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#evaluate\&quot;&gt;&lt;code&gt;#evaluate&lt;/code&gt;&lt;/a&gt; method, which is called by the\n&lt;code&gt;myphysicslab.lab.model.DiffEqSolver&lt;/code&gt; at\nthe request of the &lt;code&gt;myphysicslab.lab.model.AdvanceStrategy&lt;/code&gt; to advance the state\nof the simulation.&lt;/p&gt;\n&lt;h3&gt;Parameters Created&lt;/h3&gt;\n&lt;ul&gt;&lt;li&gt;ParameterString named &lt;code&gt;EXTRA_ACCEL&lt;/code&gt;, see &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#setExtraAccel\&quot;&gt;&lt;code&gt;#setExtraAccel&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;See also the super class for additional Parameters.&lt;/p&gt;\n&lt;h3&gt;Background and References&lt;/h3&gt;\n&lt;p&gt;See explanations at:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;&lt;a href=\&quot;Engine2D.html\&quot;&gt;2D Physics Engine Overview&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;The math and physics underlying\n&lt;a href=\&quot;http://www.myphysicslab.com/engine2D/rigid-body-en.html\&quot;&gt;RigidBodySim&lt;/a&gt;,\n&lt;a href=\&quot;http://www.myphysicslab.com/engine2D/collision-en.html\&quot;&gt;ImpulseSim&lt;/a&gt; and\n&lt;a href=\&quot;http://www.myphysicslab.com/engine2D/contact-en.html\&quot;&gt;ContactSim&lt;/a&gt; are\ndescribed on the myPhysicsLab website.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;a href=\&quot;ContactSim_Math.html\&quot;&gt;ContactSim Math&lt;/a&gt;  has more details about the math.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;The algorithm used here is based on these papers:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;David Baraff, &lt;a href=\&quot;Baraff_Fast_Contact_Force_94.pdf\&quot;&gt;Fast Contact Force Computation for Nonpenetrating Rigid Bodies.&lt;/a&gt;\nComputer Graphics Proceedings, Annual Conference Series, 1994; pages 23-34.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;David Baraff, &lt;a href=\&quot;Baraff_Siggraph_97_Course_Notes.pdf\&quot;&gt;An Introduction to Physically Based Modeling: Rigid Body Simulation II—Nonpenetration Constraints.&lt;/a&gt;\nSiggraph &amp;#39;97 Course Notes.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;See also the &lt;a href=\&quot;http://www-2.cs.cmu.edu/~baraff/papers/index.html\&quot;&gt;list of David Baraff&amp;#39;s papers&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;See the paper &lt;a href=\&quot;CEP_Curved_Edge_Physics.pdf\&quot;&gt;Curved Edge Physics paper&lt;/a&gt; by Erik Neumann\nfor modifications to contact forces when curved edges are involved.&lt;/p&gt;\n&lt;h3&gt;Find External Forces&lt;/h3&gt;\n&lt;p&gt;Within &lt;code&gt;evaluate()&lt;/code&gt; we first let the super-class apply the external forces to the\nRigidBody objects. The external forces include things like gravity, thrust, springs,\ndamping. The external forces result in accelerations of the bodies, so at this point\nmany of the bodies would start to penetrate into each other if we did not find contact\nforces to prevent that.&lt;/p&gt;\n&lt;h3&gt;Find Contacts&lt;/h3&gt;\n&lt;p&gt;Next in &lt;code&gt;evaluate()&lt;/code&gt; we call &lt;code&gt;findCollisions()&lt;/code&gt; to find all the contact points, and\npossibly collisions as well. If we find any actual (penetrating) collisions, then\n&lt;code&gt;evaluate()&lt;/code&gt; returns the set of collisions found, which should then be handled before\ntrying to step forward again, see &lt;a href=\&quot;myphysicslab.lab.engine2D.ImpulseSim.html\&quot;&gt;&lt;code&gt;ImpulseSim&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;The criteria for finding a contact is:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;the corner (or edge) of one body must be &lt;em&gt;very close&lt;/em&gt; to the edge of the other body,\nas specified by &lt;code&gt;getDistanceTol()&lt;/code&gt;.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;the bodies must be &lt;em&gt;moving very slowly&lt;/em&gt; relative to each other (the normal velocity)\nat the contact point, as specified by &lt;code&gt;getVelocityTol()&lt;/code&gt;.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;The &lt;code&gt;evaluate()&lt;/code&gt; method optionally finds independent subsets of collisions, because that\ncan make the compute_forces algorithm, which is &lt;code&gt;O(n^4)&lt;/code&gt;, run faster in some cases. See\nthe flag &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#module$exports$myphysicslab$lab$engine2D$ContactSim.SUBSET_COLLISIONS\&quot;&gt;&lt;code&gt;#SUBSET_COLLISIONS&lt;/code&gt;&lt;/a&gt;. Collisions are independent when there is no chain\nof moveable (finite mass) bodies in common between the collisions.&lt;/p&gt;\n&lt;h3&gt;The Matrix Equation for Contact Forces&lt;/h3&gt;\n&lt;p&gt;Now we have the set of contacts and we know the accelerations of the bodies due to\nexternal forces. We set up a matrix equation&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a &amp;#61; A f &amp;#43; b\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;where&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;&lt;code&gt;a &amp;#61;&lt;/code&gt; vector of accelerations&lt;/li&gt;&lt;li&gt;&lt;code&gt;A &amp;#61;&lt;/code&gt; matrix describing how the &lt;code&gt;j&lt;/code&gt;-th contact force affects the acceleration of\nthe &lt;code&gt;i&lt;/code&gt;-th &lt;em&gt;contact distance&lt;/em&gt; (the separation between the bodies)&lt;/li&gt;&lt;li&gt;&lt;code&gt;f &amp;#61;&lt;/code&gt; vector of contact forces (to be found)&lt;/li&gt;&lt;li&gt;&lt;code&gt;b &amp;#61;&lt;/code&gt; external forces (gravity, thrust, rubber band, damping)&lt;/li&gt;&lt;/ul&gt;\n&lt;h3&gt;Set Up the A Matrix&lt;/h3&gt;\n&lt;p&gt;Here is how to set up the &lt;code&gt;A&lt;/code&gt; matrix: For each contact distance &lt;code&gt;d_i&lt;/code&gt;, find how the\nacceleration of that contact distance &lt;code&gt;d_i&amp;#39;&amp;#39;&lt;/code&gt; is related to the force at the &lt;code&gt;j&lt;/code&gt;-th\ncontact point. The force at the &lt;code&gt;j&lt;/code&gt;-th contact point is &lt;code&gt;f_j N_j&lt;/code&gt;, where &lt;code&gt;f_j&lt;/code&gt; is a\nscalar and &lt;code&gt;N_j&lt;/code&gt; is the vector normal. The &lt;code&gt;a_ij&lt;/code&gt; entry in the &lt;code&gt;A&lt;/code&gt; matrix tells what\nthat relationship is between &lt;code&gt;f_j&lt;/code&gt; and &lt;code&gt;d_i&amp;#39;&amp;#39;&lt;/code&gt;. This &lt;code&gt;a_ij&lt;/code&gt; value is dependent only on\nthe current geometry of how the objects are oriented and touching each other.&lt;/p&gt;\n&lt;img src=\&quot;Baraff_Figure26.png\&quot; alt=\&quot;Baraff Figure 26\&quot; /&gt;\n&lt;p&gt;For example, consider Figure 26 of\n&lt;a href=\&quot;Baraff_Siggraph_97_Course_Notes.pdf\&quot;&gt;Baraffs Siggraph 97 Course Notes&lt;/a&gt;\nshown above. The figure shows two bodies\n(B,C) resting on the ground, and a third body (A) resting on top of the other two. There\nare 5 points of contact among the bodies and the ground. Here is how the matrix\nequation would look for this situation:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a1     a11  a12  a13   0    0     f1     b1\na2     a21  a22  a23   0    0     f2     b2\na3  &amp;#61;  a31  a32  a33  a34   0  *  f3  &amp;#43;  b3\na4      0    0   a43  a44  a45    f4     b4\na5      0    0    0   a54  a55    f5     b5\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;Consider the first contact at &lt;code&gt;p1&lt;/code&gt; which is between the ground and body B. The\nacceleration of the contact distance at &lt;code&gt;p1&lt;/code&gt; is affected by the forces at &lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;p2&lt;/code&gt;,\nand &lt;code&gt;p3&lt;/code&gt; because all of those forces affect the movement of body B. But the forces at\n&lt;code&gt;p4&lt;/code&gt; and &lt;code&gt;p5&lt;/code&gt; have no effect, so their entries are zero in the first row of the &lt;code&gt;A&lt;/code&gt;\nmatrix.&lt;/p&gt;\n&lt;p&gt;The first row of the matrix equation can be written out as&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a1 &amp;#61; a11*f1 &amp;#43; a12*f2 &amp;#43; a13*f3 &amp;#43; 0*f4 &amp;#43; 0*f5 &amp;#43; b1\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;That equation says the acceleration of contact distance at point &lt;code&gt;p1&lt;/code&gt; is equal to a\ncertain linear combination of the contact forces &lt;code&gt;f1&lt;/code&gt;, &lt;code&gt;f2&lt;/code&gt;, &lt;code&gt;f3&lt;/code&gt;, plus the acceleration\ndue to the external forces which is &lt;code&gt;b1&lt;/code&gt;.&lt;/p&gt;\n&lt;p&gt;The particular values for &lt;code&gt;a11, a12, a13&lt;/code&gt; are dependent on the geometry of the\nsituation: where the forces &lt;code&gt;f1&lt;/code&gt;, &lt;code&gt;f2&lt;/code&gt;, &lt;code&gt;f3&lt;/code&gt; are applied on the body; in what direction\ndo the forces act; where is the center of mass of the body; how the force causes the\nbody to accelerate and spin; where is the point &lt;code&gt;p1&lt;/code&gt; is in relation to the center of\nmass; etc.&lt;/p&gt;\n&lt;p&gt;The third contact at &lt;code&gt;p3&lt;/code&gt; is more complicated because it is affected by any forces\nacting on body A or body B. These include all the forces except &lt;code&gt;f5&lt;/code&gt;. Therefore the\nthird row of the &lt;code&gt;A&lt;/code&gt; matrix has four non-zero entries corresponding to the four forces\nthat affect the acceleration at &lt;code&gt;p3&lt;/code&gt;.&lt;/p&gt;\n&lt;h3&gt;Constraints On the Solution&lt;/h3&gt;\n&lt;p&gt;Assume we now have the &lt;code&gt;b&lt;/code&gt; vector of external forces and the &lt;code&gt;A&lt;/code&gt; matrix of dependencies\nbetween contact forces and resulting accelerations of different bodies. We solve for the\n&lt;code&gt;f&lt;/code&gt; vector of contact forces subject to the following constraints:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a &amp;gt;&amp;#61; 0\nf &amp;gt;&amp;#61; 0\na.f &amp;#61; 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The constraints in words are:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a &amp;gt;&amp;#61; 0&lt;/code&gt;  we require all the relative normal accelerations (between bodies\nat contact points) to be either zero (remain in contact) or positive (separating).&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;f &amp;gt;&amp;#61; 0&lt;/code&gt;  We require contact forces to be zero or positive because they can\nonly push, not pull.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a.f &amp;#61; 0&lt;/code&gt;  The third constraint is a math way of saying that\nif there is a force, then acceleration is zero OR\nif there is acceleration (separation), then there is no force.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;Note that for Joints the constraints are different:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;a &amp;#61;&amp;#61; 0&lt;/code&gt;  a Joint always remains in resting contact, it never separates&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;No constraint on &lt;code&gt;f&lt;/code&gt; because it can push or pull.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;h3&gt;Solving For the Contact Forces&lt;/h3&gt;\n&lt;p&gt;The &lt;a href=\&quot;Baraff_Fast_Contact_Force_94.pdf\&quot;&gt;Baraff &amp;#39;Fast Contact Force&amp;#39; paper&lt;/a&gt; goes into full\ndetail about the algorithm to solve this constraint problem.  Here is a quick summary:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;Start by setting all the forces to zero&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;Add in one force at a time, just enough to maintain the constraints on the points that\nhave been considered so far (ignoring the others), and readjust the other forces as\nnecessary.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;Continue adding one force at a time, ignoring points that haven&amp;#39;t been considered yet.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;Suppose that we are working on adding in the third force after already finding the\nforces for points 1 and 2. The trick is that we only look at the constraints on the\nfirst 3 contact points, we ignore the other contact points and other forces. Once we&amp;#39;ve\nfound the 3rd force (and rebalanced forces 1 and 2 as needed) we then move on to\nconsider the 4th force.&lt;/p&gt;\n&lt;p&gt;The last step is to &lt;strong&gt;apply the contact forces&lt;/strong&gt; to the bodies, which gives the final\nset of accelerations that the &lt;code&gt;evaluate()&lt;/code&gt; method then returns to the differential\nequation solver.&lt;/p&gt;\n&lt;h3&gt;Extra Acceleration&lt;/h3&gt;\n&lt;p&gt;The contact forces are calculated so that there is zero acceleration at contact points; but this does not immediately affect the remaining small velocity at a contact point.  As a result, objects that are in resting contact will often have some undesirable jittery motion.&lt;/p&gt;\n&lt;p&gt;One way to deal with this is to request a small amount of additional acceleration which will eliminate that velocity over a few time steps.  If the objects are moving towards each other (a small negative velocity) we request a little more acceleration which leads to a little more force being applied there.  If the objects are moving apart (a small positive velocity) we request a little less acceleration.&lt;/p&gt;\n&lt;p&gt;The extra acceleration is added to the &lt;code&gt;b&lt;/code&gt; vector in the private method\n&lt;code&gt;calculate_b_vector&lt;/code&gt;. See &lt;a href=\&quot;myphysicslab.lab.engine2D.ExtraAccel.html\&quot;&gt;&lt;code&gt;ExtraAccel&lt;/code&gt;&lt;/a&gt; enum for\nexplanations of the various options. See &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#setExtraAccel\&quot;&gt;&lt;code&gt;#setExtraAccel&lt;/code&gt;&lt;/a&gt; for how to specify the\ndesired ExtraAccel option.&lt;/p&gt;\n&lt;h3&gt;Intermediate Steps During &lt;code&gt;evaluate&lt;/code&gt;&lt;/h3&gt;\n&lt;p&gt;A DiffEqSolver works by &amp;#39;averaging&amp;#39; several calculated states for each time step; for\nexample ModifiedEuler averages 2 states, and RungeKutta averages 4 states. The collision\ndetection done in &lt;code&gt;evaluate()&lt;/code&gt; is based on those intermediate states within a step of\nthe DiffEqSolver, so it is arguable whether that state actually ever occurs.&lt;/p&gt;\n&lt;p&gt;This point of view argues for only using the collisions detected between full steps of\nthe DiffEqSolver. However, contacts can come and go during these sub-steps so it seems\nin practice to be more accurate to find the set of contacts anew in each call to\n&lt;code&gt;evaluate()&lt;/code&gt;. Also if a penetrating collision is detected we need to stop the process\nand handle that collision instead, so it is important to do collision detection for that\nas well.&lt;/p&gt;\n&lt;p&gt;Prior to February 2012, there was an experimental option specified by the flag\n&lt;code&gt;REUSE_COLLISIONS&lt;/code&gt; for which we did &lt;em&gt;not&lt;/em&gt; find the collisions anew in the &lt;code&gt;evaluate()&lt;/code&gt;\nmethod, instead we used the collisions found outside the &lt;code&gt;evaluate()&lt;/code&gt; method during\n&lt;code&gt;AdvanceStrategy.advance()&lt;/code&gt; which are based on a complete ODE step. See the git archive.&lt;/p&gt;\n&quot;]]],null,null,[null,null,null,null,null,1],null,null,[],[]],[],1,[[&quot;opt_name&quot;,[1,null,null,null,null,[[[null,null,null,[&quot;string&quot;,null,null,1,[]]],[null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;name of this Subject&lt;/p&gt;\n&quot;]]]]],null,[]],[[[&quot;addBody&quot;,[null,451,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Add the Polygon to the simulation and SimList, adds a set of variables to the\nVarsList, and sets the simulation state to match the Polygon state (by copying the\nPolygon&amp;#39;s position and velocity to the simulation&amp;#39;s VarsList).&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#addBody&quot;]],null,[]],[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#addBody&quot;]],null,[]],[],[]],[],null,[[&quot;body&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.Polygon&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Polygon.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;Polygon to add to the simulation&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;addConnector&quot;,[null,424,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Adds a Connector to the list of active Connectors and to the\n&lt;code&gt;com.SimList&lt;/code&gt;.\nThe RigidBodys of the Connector must already have been added to this ContactSim,\nunless it is a Scrim.  Note that the order of the list of Connectors is significant,\nsee &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#alignConnectors\&quot;&gt;&lt;code&gt;#alignConnectors&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;connector&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.Connector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Connector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Connector to add&lt;/p&gt;\n&quot;]]]],[&quot;follow&quot;,[1,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.engine2D.Connector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Connector.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,null,1],[null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;add new Connector into list after\nthis Connector; if null then add at front of list; if undefined, add at end of list&lt;/p&gt;\n&quot;]]]]],null,[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if RigidBodys of the Connector have not been added to this\nContactSim&lt;/p&gt;\n&quot;]]]]]],[[&quot;addConnectors&quot;,[null,456,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Adds the set of Connectors.  Note that the ordering of the Connectors is\nimportant because the Connectors are aligned in list order.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;connectors&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.engine2D.Connector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Connector.html&quot;]],null,[]]]]]],[[[null,&quot;&lt;p&gt;set of Connectors\nto add&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;addForceLaw&quot;,[null,519,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Adds the ForceLaw to the list of ForceLaws operating in this simulation, if it is\nnot already on the list.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#addForceLaw&quot;]],null,[]],null,[],[]],[],null,[[&quot;forceLaw&quot;,[null,null,null,[&quot;myphysicslab.lab.model.ForceLaw&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.ForceLaw.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the ForceLaw to add&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;addObserver&quot;,[null,89,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Adds the given Observer to the Subject&amp;#39;s list of Observers, so that the Observer\nwill be notified of changes in this Subject. An Observer may call &lt;code&gt;Subject.addObserver&lt;/code&gt;\nduring its &lt;code&gt;observe&lt;/code&gt; method.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#addObserver&quot;]],null,[]],[],[]],[],null,[[&quot;observer&quot;,[null,null,null,[&quot;myphysicslab.lab.util.Observer&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Observer.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Observer to add&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;addParameter&quot;,[null,129,null,[null,null,&quot;source/src/lab/util/AbstractSubject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Adds the Parameter to the list of this Subject&amp;#39;s available Parameters.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#addParameter&quot;]],null,[]],null,[],[]],[],null,[[&quot;parameter&quot;,[null,null,null,[&quot;myphysicslab.lab.util.Parameter&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Parameter.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Parameter to add&lt;/p&gt;\n&quot;]]]]],null,[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if a Parameter with the same name already exists.&lt;/p&gt;\n&quot;]]]]]],[[&quot;alignConnectors&quot;,[null,487,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Aligns all Connectors. This is generally done only during set up of initial\nconditions of the simulation, or whenever a Connector is being created.&lt;/p&gt;\n&lt;p&gt;Note that the order of the bodies within a Joint is significant because &lt;code&gt;Joint.align()&lt;/code&gt;\nusually moves the second body to align with first body. Also, the ordering within the\nlist of Connectors is significant because the Connectors are aligned in list order.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],null,[]],[[&quot;applyForce&quot;,[null,667,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Applies the Force by modifying the array representing rate of change of each\nvariable.  The Force specifies which RigidBody it works on so we can figure out\nwhich variable rates to modify.  Adds the Force to the SimList with an immediate\nexpiration time.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#applyForce&quot;]],null,[]],null,[],[],[null,1]],[],null,[[&quot;change&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;vector of rigid body accelerations&lt;/p&gt;\n&quot;]]]],[&quot;force&quot;,[null,null,null,[&quot;myphysicslab.lab.model.Force&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Force.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Force to be applied&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;broadcast&quot;,[null,98,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Notifies all Observers that the Subject has changed by calling\n&lt;code&gt;observe&lt;/code&gt; on each Observer.\nAn Observer may call &lt;code&gt;Subject.addObserver&lt;/code&gt; or &lt;code&gt;Subject.removeObserver&lt;/code&gt; during its\n&lt;code&gt;observe&lt;/code&gt; method.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#broadcast&quot;]],null,[]],[],[]],[],null,[[&quot;evt&quot;,[null,null,null,[&quot;myphysicslab.lab.util.SubjectEvent&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.SubjectEvent.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;a SubjectEvent with information\nrelating to the change&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;broadcastParameter&quot;,[null,106,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Notifies all Observers that the Parameter with the given &lt;code&gt;name&lt;/code&gt; has changed by\ncalling &lt;code&gt;observe&lt;/code&gt; on each Observer.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#broadcastParameter&quot;]],null,[]],[],[]],[],null,[[&quot;name&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the language-independent or English name of the Parameter\nthat has changed&lt;/p&gt;\n&quot;]]]]],null,[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if there is no Parameter with the given name&lt;/p&gt;\n&quot;]]]]]],[[&quot;cleanSlate&quot;,[null,381,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Removes all RigidBodys, ForceLaws, most Variables, and clears the SimList. This is\nused in applications to build a new configuration of RigidBodys. This should give\nessentially the same state that you would get from making a new RigidBodySim, except for\nparameters that have been changed.&lt;/p&gt;\n&lt;p&gt;The alternative is to create a new RigidBodySim; that would be &amp;#39;cleaner&amp;#39; but then you\nmust unhook the old RigidBodySim from all the various user controls and graph and such,\nand hook up the new one.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#cleanSlate&quot;]],null,[]],[],[]],[],null,[],null,[]],[[&quot;clearForceLaws&quot;,[null,557,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Clears the list of ForceLaws operating in this simulation.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#clearForceLaws&quot;]],null,[]],null,[],[]],[],null,[],null,[]],[[&quot;debugCircle&quot;,[null,44,null,[null,null,&quot;source/src/lab/engine2D/DebugEngine2D.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Creates a PointMass which is displayed as a circle, and adds it to the\nSimList, for debugging only.\nThe expiration time on temporary SimObjects is set to &amp;#39;now&amp;#39;, so that they are\nremoved right away during the next call to advance().&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#debugCircle&quot;]],null,[]],[],[]],[],null,[[&quot;name&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;name of the SimObject that is created&lt;/p&gt;\n&quot;]]]],[&quot;center&quot;,[null,null,null,[&quot;myphysicslab.lab.util.GenericVector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.GenericVector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;center of the circle&lt;/p&gt;\n&quot;]]]],[&quot;radius&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;radius of the circle&lt;/p&gt;\n&quot;]]]],[&quot;expireTime&quot;,[1,null,null,null,null,[[[null,null,null,[&quot;number&quot;,null,null,1,[]]],[null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;the time when the DisplayObject will be removed;\nthe default expireTime is &amp;#39;now&amp;#39;.&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;debugLine&quot;,[null,55,null,[null,null,&quot;source/src/lab/engine2D/DebugEngine2D.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Creates a ConcreteLine and adds it to the SimList, for debugging only.\nThe expiration time on temporary SimObjects is set to &amp;#39;now&amp;#39;, so that they are\nremoved right away during the next call to advance().&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#debugLine&quot;]],null,[]],[],[]],[],null,[[&quot;name&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;name of the SimObject that is created&lt;/p&gt;\n&quot;]]]],[&quot;pa&quot;,[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;starting point of the line&lt;/p&gt;\n&quot;]]]],[&quot;pb&quot;,[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;ending point of the line&lt;/p&gt;\n&quot;]]]],[&quot;expireTime&quot;,[1,null,null,null,null,[[[null,null,null,[&quot;number&quot;,null,null,1,[]]],[null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;the time when the DisplayObject will be removed;\nthe default expireTime is &amp;#39;now&amp;#39;.&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;evaluate&quot;,[null,508,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Defines the differential equations of this ODESim; for an input set of variables,\nreturns the current rate of change for each variable (the first derivative of each\nvariable with respect to time).&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;timeStep&lt;/code&gt; is the time since the state variables were last fully calculated, which\ncan be and often is zero. The current time can be regarded as &lt;code&gt;getTime() &amp;#43; timeStep&lt;/code&gt;.\nThe input variables correspond to the Simulation state at that time. Note that\n&lt;code&gt;timeStep&lt;/code&gt; is different from the time step used to advance the Simulation (as in\n&lt;code&gt;myphysicslab.lab.model.AdvanceStrategy#advance&lt;/code&gt;). The &lt;code&gt;timeStep&lt;/code&gt; is typically\nused when finding collisions, see for example\n&lt;code&gt;myphysicslab.lab.model.CollisionSim#findCollisions&lt;/code&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#evaluate&quot;]],null,[]],[[&quot;myphysicslab.lab.model.ODESim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.ODESim.html#evaluate&quot;]],null,[]]],[]],[],null,[[&quot;vars&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;the current array of state variables (input),\ncorresponding to the state at &lt;code&gt;getTime() &amp;#43; timeStep&lt;/code&gt;&lt;/p&gt;\n&quot;]]]],[&quot;change&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;array of change rates for each variable (output), all\nvalues are zero on entry.&lt;/p&gt;\n&quot;]]]],[&quot;timeStep&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the current time step (might be zero)&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,null,null,[[[null,null,null,[&quot;Object&quot;,null,null,1,[]]],[null,null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;&lt;code&gt;null&lt;/code&gt; if the evaluation succeeds, otherwise an object relating to the\nerror that occurred. The &lt;code&gt;change&lt;/code&gt; array contains the output results.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;findCollisions&quot;,[null,649,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Finds collisions based on the passed in state variables. Can rely on\n&lt;code&gt;ODESim#modifyObjects&lt;/code&gt; having been called prior, with this\nset of state variables. Uses the state saved by\n&lt;code&gt;ODESim#saveState&lt;/code&gt; as the &amp;#39;before&amp;#39; state for comparison.&lt;/p&gt;\n&lt;p&gt;The list of collisions that are passed in can potentially have collisions from the\nnear future that were found previously. The CollisionSim should avoid adding collisions\nthat are duplicates of those already on the list.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#findCollisions&quot;]],null,[]],[[&quot;myphysicslab.lab.model.CollisionSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.CollisionSim.html#findCollisions&quot;]],null,[]]],[]],[],null,[[&quot;collisions&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html&quot;]],null,[]]]]]],[[[null,&quot;&lt;p&gt;the list of collisions to add to&lt;/p&gt;\n&quot;]]]],[&quot;vars&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;the current array of state variables&lt;/p&gt;\n&quot;]]]],[&quot;stepSize&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the size of the current time step, in seconds&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;formatVars&quot;,[null,318,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns string showing current variables of each RigidBody, for debugging.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#formatVars&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;string showing current variables of each RigidBody, for debugging.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getBodies&quot;,[null,448,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the list of Polygons in this simulation.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#getBodies&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.engine2D.Polygon&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Polygon.html&quot;]],null,[]]]]]],[[[null,&quot;&lt;p&gt;list of Polygons in this\nRigidBodySim.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getBody&quot;,[null,460,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns a Polygon in this simulation by specifying its name or index in the list\nof Polygons.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#getBody&quot;]],null,[]],null,[],[]],[],null,[[&quot;numOrName&quot;,[null,null,null,null,null,[[[null,null,null,[&quot;number&quot;,null,null,1,[]]],[null,null,null,[&quot;string&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;index in list of Polygons or name of the Polygon\n(either the English or language-independent version of the name)&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;myphysicslab.lab.engine2D.Polygon&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Polygon.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Polygon with the given name or at\nthe given position in the list of Polygons&lt;/p&gt;\n&quot;]]]],[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if requesting a non-existing body.&lt;/p&gt;\n&quot;]]]]]],[[&quot;getBroadcast&quot;,[null,169,null,[null,null,&quot;source/src/lab/util/AbstractSubject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns whether broadcasting is enabled for this Subject.\nSee &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#setBroadcast\&quot;&gt;&lt;code&gt;#setBroadcast&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#getBroadcast&quot;]],null,[]],null,[],[],[null,1]],[],null,[],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether broadcasting is enabled for this Subject&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getClassName&quot;,[null,337,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns name of class of this object.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#getClassName&quot;]],null,[]],[],[]],[],null,[],[null,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;name of class of this object.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getCollisionAccuracy&quot;,[null,361,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the collision distance accuracy, a fraction between zero and one; when the\ncollision distance is within &lt;code&gt;accuracy * targetGap&lt;/code&gt; of the target gap distance, then\nthe collision is considered close enough to handle (apply an impulse).&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#getCollisionAccuracy&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the collision accuracy, a fraction between 0 (exclusive) and 1\n(inclusive)&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getCollisionHandling&quot;,[null,338,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the collision handling method being used.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#getCollisionHandling&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.engine2D.CollisionHandling&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.CollisionHandling.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the collision handling method\nbeing used, from &lt;a href=\&quot;myphysicslab.lab.engine2D.CollisionHandling.html\&quot;&gt;&lt;code&gt;CollisionHandling&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getConnectors&quot;,[null,474,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the list of active Connectors.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.engine2D.Connector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Connector.html&quot;]],null,[]]]]]],[[[null,&quot;&lt;p&gt;the list of active Connectors&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getDistanceTol&quot;,[null,387,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns distance tolerance used to determine if an object is in contact with another\nobject&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#getDistanceTol&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;distance tolerance used to determine if an object is in contact with\nanother object&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getEnergyInfo&quot;,[null,30,null,[null,null,&quot;source/src/lab/model/EnergySystem.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the current EnergyInfo for this system.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#getEnergyInfo&quot;]],null,[]],[],[]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.model.EnergyInfo&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.EnergyInfo.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;an EnergyInfo object representing\nthe current energy of this system.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getExtraAccel&quot;,[null,346,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the method to use for calculating extra acceleration added to\neliminate small amount of remaining velocity at a contact.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.engine2D.ExtraAccel&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ExtraAccel.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the method to use for calculating\nextra acceleration, from &lt;a href=\&quot;myphysicslab.lab.engine2D.ExtraAccel.html\&quot;&gt;&lt;code&gt;ExtraAccel&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getExtraAccelTimeStep&quot;,[null,376,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the approximate length of a time step, used to find extra acceleration\nneeded to keep contact points at the proper distance apart.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the approximate length of a time step&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getForceLaws&quot;,[null,567,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the list of ForceLaws operating in this simulation.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#getForceLaws&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.model.ForceLaw&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.ForceLaw.html&quot;]],null,[]]]]]],[[[null,&quot;&lt;p&gt;list of ForceLaws operating in\nthis simulation&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getName&quot;,[null,111,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Return the language-independent name of this Subject for scripting purposes.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#getName&quot;]],null,[]],[],[]],[],null,[],[null,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;name the language-independent name of this Subject&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getNumContacts&quot;,[null,503,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;For debugging, returns the number of contacts in the biggest subset of contacts\nthat are all interrelated.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;number of contacts in the biggest subset of contacts that\nare all interrelated&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getObservers&quot;,[null,117,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns a copy of the list of Observers of this Subject.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#getObservers&quot;]],null,[]],[],[]],[],null,[],[null,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.util.Observer&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Observer.html&quot;]],null,[]]]]]],[[[null,&quot;&lt;p&gt;a copy of the list of Observers of\nthis Subject.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getParameter&quot;,[null,124,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the Parameter with the given name.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#getParameter&quot;]],null,[]],[],[]],[],null,[[&quot;name&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the language-independent or English name of the Parameter&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;myphysicslab.lab.util.Parameter&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Parameter.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Parameter with the given name&lt;/p&gt;\n&quot;]]]],[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if there is no Parameter with the given name&lt;/p&gt;\n&quot;]]]]]],[[&quot;getParameterBoolean&quot;,[null,138,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the ParameterBoolean with the given name.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#getParameterBoolean&quot;]],null,[]],[],[]],[],null,[[&quot;name&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the language-independent or English name of the ParameterBoolean&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;myphysicslab.lab.util.ParameterBoolean&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.ParameterBoolean.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the ParameterBoolean with\nthe given name&lt;/p&gt;\n&quot;]]]],[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if there is no ParameterBoolean with the given name&lt;/p&gt;\n&quot;]]]]]],[[&quot;getParameterNumber&quot;,[null,146,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the ParameterNumber with the given name.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#getParameterNumber&quot;]],null,[]],[],[]],[],null,[[&quot;name&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the language-independent or English name of the ParameterNumber&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;myphysicslab.lab.util.ParameterNumber&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.ParameterNumber.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the ParameterNumber with\nthe given name&lt;/p&gt;\n&quot;]]]],[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if there is no ParameterNumber with the given name&lt;/p&gt;\n&quot;]]]]]],[[&quot;getParameterString&quot;,[null,154,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the ParameterString with the given name.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#getParameterString&quot;]],null,[]],[],[]],[],null,[[&quot;name&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the language-independent or English name of the ParameterString&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;myphysicslab.lab.util.ParameterString&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.ParameterString.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the ParameterString with\nthe given name&lt;/p&gt;\n&quot;]]]],[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if there is no ParameterString with the given name&lt;/p&gt;\n&quot;]]]]]],[[&quot;getParameters&quot;,[null,130,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns a copy of the list of this Subject&amp;#39;s available Parameters.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#getParameters&quot;]],null,[]],[],[]],[],null,[],[null,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.util.Parameter&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Parameter.html&quot;]],null,[]]]]]],[[[null,&quot;&lt;p&gt;a copy of the list of\navailable Parameters for this Subject&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getRandomSeed&quot;,[null,318,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the seed of the pseudo random number generator (RNG) used in this\nsimulation. The RNG is used during collision handling and contact force calculation. To\nget reproducible results, set this seed at the start of a simulation, and the RNG will\nthen always give the same sequence of random numbers.\nSee &lt;a href=\&quot;myphysicslab.lab.util.Random.html\&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#getRandomSeed&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the seed of the pseudo random number generator&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getShowCollisions&quot;,[null,438,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Whether to to show collisions visually.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#getShowCollisions&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether to show collisions visually.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getShowForces&quot;,[null,287,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Whether to add Forces to the SimList so they can be seen.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#getShowForces&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether to add Forces to the SimList so they can be seen&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getSimList&quot;,[null,50,null,[null,null,&quot;source/src/lab/model/Simulation.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the list of &lt;a href=\&quot;myphysicslab.lab.model.SimObject.html\&quot;&gt;&lt;code&gt;SimObject&lt;/code&gt;&lt;/a&gt;s that represent this Simulation.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#getSimList&quot;]],null,[]],[],[]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.model.SimList&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.SimList.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the list of SimObjects that represent this simulation&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getSimRect&quot;,[null,303,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the suggested size for the SimView. This is mainly for tests to communicate\nwith &lt;code&gt;myphysicslab.test.TestViewerApp&lt;/code&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#getSimRect&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.util.DoubleRect&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.DoubleRect.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;suggested size for the SimView&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getTime&quot;,[null,56,null,[null,null,&quot;source/src/lab/model/Simulation.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the current Simulation time.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#getTime&quot;]],null,[]],[[&quot;myphysicslab.lab.engine2D.DebugEngine2D&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.DebugEngine2D.html#getTime&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the current Simulation time.&lt;/p&gt;\n&quot;]]]],[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if there is no time variable for the simulation&lt;/p&gt;\n&quot;]]]]]],[[&quot;getVarsList&quot;,[null,64,null,[null,null,&quot;source/src/lab/model/ODESim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the VarsList that represents the current state of this Simulation.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#getVarsList&quot;]],null,[]],[],[]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.model.VarsList&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.VarsList.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the VarsList that represents the current\nstate of this Simulation&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getVelocityTol&quot;,[null,409,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns velocity tolerance used to determine if an object is in contact with another\nobject&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#getVelocityTol&quot;]],null,[]],null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;velocity tolerance used to determine if an object is in contact with\nanother object&lt;/p&gt;\n&quot;]]]],[]],[[&quot;handleCollisions&quot;,[null,57,null,[null,null,&quot;source/src/lab/model/CollisionSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Adjusts the simulation state based on the given Collisions.\nFor example, this might reverse the velocities of objects colliding against a wall.\nThe simulation state is contained in the &lt;code&gt;vars&lt;/code&gt; array of state variables from\n&lt;a href=\&quot;myphysicslab.lab.model.ODESim.html#getVarsList\&quot;&gt;&lt;code&gt;ODESim#getVarsList&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Note that these Collisions will typically be from the very near future;\n&lt;code&gt;myphysicslab.lab.model.CollisionAdvance&lt;/code&gt; backs up to just before the moment of collision\nbefore handling Collisions.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#handleCollisions&quot;]],null,[]],[],[]],[],null,[[&quot;collisions&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html&quot;]],null,[]]]]]],[[[null,&quot;&lt;p&gt;the list of current collisions&lt;/p&gt;\n&quot;]]]],[&quot;opt_totals&quot;,[1,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.model.CollisionTotals&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.CollisionTotals.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;CollisionTotals object\nto update with number of collisions handled (optional)&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if was able to handle the collision, changing state of\nsimulation.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;initializeFromBody&quot;,[null,486,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the simulation variables to match the Polygon state (by copying the Polygon&amp;#39;s\nposition and velocity to the simulation&amp;#39;s VarsList).&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#initializeFromBody&quot;]],null,[]],null,[],[]],[],null,[[&quot;body&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.Polygon&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Polygon.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Polygon to use for updating\nthe simulation variables&lt;/p&gt;\n&quot;]]]]],null,[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if the body is not recognized&lt;/p&gt;\n&quot;]]]]]],[[&quot;makeCollisionMatrix&quot;,[null,710,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns a matrix where the &lt;code&gt;(i, j)&lt;/code&gt;th entry is how much the relative normal\nvelocity at collision &lt;code&gt;i&lt;/code&gt; will change from a unit impulse being applied at\ncollision &lt;code&gt;j&lt;/code&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#makeCollisionMatrix&quot;]],null,[]],null,[],[],[null,1]],[],null,[[&quot;collisions&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodyCollision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html&quot;]],null,[]]]]]],[[[null,&quot;&lt;p&gt;list of\nRigidBodyCollisions&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;Float64Array&quot;,null,null,null,[]]]]]],[[[null,&quot;&lt;p&gt;matrix that tells how much impulse\nat collision point &lt;code&gt;i&lt;/code&gt; affects relative normal velocity at collision point &lt;code&gt;j&lt;/code&gt;&lt;/p&gt;\n&quot;]]]],[]],[[&quot;modifyObjects&quot;,[null,61,null,[null,null,&quot;source/src/lab/model/Simulation.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Updates the SimObjects to match the current internal state of the Simulation.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#modifyObjects&quot;]],null,[]],[],[]],[],null,[],null,[]],[[&quot;moveObjects&quot;,[null,614,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Update the RigidBodys to have the position and velocity specified by the given\narray of variables.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#moveObjects&quot;]],null,[]],null,[],[],[null,1]],[],null,[[&quot;vars&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;array of variables to update from&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;myPrint&quot;,[null,70,null,[null,null,&quot;source/src/lab/engine2D/DebugEngine2D.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Prints the message to console, preceded by the current simulation time. Draws the\ntime in green, the message in black; you can change colors in the message by adding more\n&amp;#39;%c&amp;#39; symbols in the message string and pass additional colors.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#myPrint&quot;]],null,[]],[],[]],[],null,[[&quot;message&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;message to print, optionally with &amp;#39;%c&amp;#39; where color changes are\ndesired&lt;/p&gt;\n&quot;]]]],[&quot;colors&quot;,[null,1,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;CSS color or background strings, to change the color in the\nmessage at points in the message marked by the string &amp;#39;%c&amp;#39;&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;removeBody&quot;,[null,402,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Removes the Polygon from the simulation, and any Connectors that were attached\nto it.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#removeBody&quot;]],null,[]],[],[]],[],null,[[&quot;body&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.Polygon&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Polygon.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;Polygons to remove from the simulation&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;removeConnector&quot;,[null,466,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Removes the Connector from the list of active Connectors. If the Connector is\nalso a SimObject, then removes it from the &lt;code&gt;com.SimList&lt;/code&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;connector&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.Connector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Connector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Connector to remove&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;removeForceLaw&quot;,[null,547,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Removes the ForceLaw from the list of ForceLaws operating in this simulation.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#removeForceLaw&quot;]],null,[]],null,[],[]],[],null,[[&quot;forceLaw&quot;,[null,null,null,[&quot;myphysicslab.lab.model.ForceLaw&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.ForceLaw.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the ForceLaw to remove&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether the ForceLaw was removed&lt;/p&gt;\n&quot;]]]],[]],[[&quot;removeObserver&quot;,[null,161,null,[null,null,&quot;source/src/lab/util/Subject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Removes the Observer from the Subject&amp;#39;s list of Observers. An Observer may\ncall &lt;code&gt;Subject.removeObserver&lt;/code&gt; during its &lt;code&gt;observe&lt;/code&gt; method.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#removeObserver&quot;]],null,[]],[],[]],[],null,[[&quot;observer&quot;,[null,null,null,[&quot;myphysicslab.lab.util.Observer&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Observer.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Observer to\ndetach from list of Observers&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;removeParameter&quot;,[null,257,null,[null,null,&quot;source/src/lab/util/AbstractSubject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Removes the Parameter from the list of this Subject&amp;#39;s available Parameters.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#removeParameter&quot;]],null,[]],null,[],[]],[],null,[[&quot;parameter&quot;,[null,null,null,[&quot;myphysicslab.lab.util.Parameter&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Parameter.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Parameter to remove&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;reset&quot;,[null,388,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the Simulation back to its initial conditions, see &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#saveInitialState\&quot;&gt;&lt;code&gt;#saveInitialState&lt;/code&gt;&lt;/a&gt;,\nand calls &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#modifyObjects\&quot;&gt;&lt;code&gt;#modifyObjects&lt;/code&gt;&lt;/a&gt;. Broadcasts event named &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html\&quot;&gt;&lt;code&gt;#RESET&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#reset&quot;]],null,[]],[[&quot;myphysicslab.lab.model.Simulation&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Simulation.html#reset&quot;]],null,[]]],[]],[],null,[],null,[]],[[&quot;restoreState&quot;,[null,69,null,[null,null,&quot;source/src/lab/model/ODESim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Restores the Simulation state that was saved with &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#saveState\&quot;&gt;&lt;code&gt;#saveState&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#restoreState&quot;]],null,[]],[],[]],[],null,[],null,[]],[[&quot;saveInitialState&quot;,[null,74,null,[null,null,&quot;source/src/lab/model/Simulation.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Saves the current variables and time as the initial state, so that this initial\nstate can be restored with &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#reset\&quot;&gt;&lt;code&gt;#reset&lt;/code&gt;&lt;/a&gt;.\nBroadcasts event named &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html\&quot;&gt;&lt;code&gt;#INITIAL_STATE_SAVED&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#saveInitialState&quot;]],null,[]],[],[]],[],null,[],null,[]],[[&quot;saveState&quot;,[null,78,null,[null,null,&quot;source/src/lab/model/ODESim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Saves the current state of the Simulation, so that we can back up to this state\nlater on. The state is defined mainly by the set of Simulation variables, see\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#getVarsList\&quot;&gt;&lt;code&gt;#getVarsList&lt;/code&gt;&lt;/a&gt;, but can include other data. This state is typically used for\ncollision detection as the &lt;em&gt;before collision&lt;/em&gt; state, see\n&lt;code&gt;myphysicslab.lab.model.CollisionSim#findCollisions&lt;/code&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#saveState&quot;]],null,[]],[],[]],[],null,[],null,[]],[[&quot;setBroadcast&quot;,[null,270,null,[null,null,&quot;source/src/lab/util/AbstractSubject.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets whether this Subject will broadcast events, typically used to temporarily\ndisable broadcasting. Intended to be used in situations where a subclass overrides a\nmethod that broadcasts an event. This allows the subclass to prevent the superclass\nbroadcasting that event, so that the subclass can broadcast the event when the method is\ncompleted.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#setBroadcast&quot;]],null,[]],null,[],[],[null,1]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether this Subject should broadcast events&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the previous value&lt;/p&gt;\n&quot;]]]],[]],[[&quot;setCollisionAccuracy&quot;,[null,371,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the collision distance accuracy, a fraction between zero and one; when the\ncollision distance is within &lt;code&gt;accuracy * targetGap&lt;/code&gt; of the target gap distance, then\nthe collision is considered close enough to handle (apply an impulse).&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#setCollisionAccuracy&quot;]],null,[]],null,[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;how close in distance to be in order to handle a collision&lt;/p&gt;\n&quot;]]]]],null,[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if value is out of the range 0 to 1, or is exactly zero&lt;/p&gt;\n&quot;]]]]]],[[&quot;setCollisionHandling&quot;,[null,346,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the collision handling method to use,&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#setCollisionHandling&quot;]],null,[]],null,[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.CollisionHandling&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.CollisionHandling.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the collision handling\nmethod to use, from &lt;a href=\&quot;myphysicslab.lab.engine2D.CollisionHandling.html\&quot;&gt;&lt;code&gt;CollisionHandling&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setDebugPaint&quot;,[null,63,null,[null,null,&quot;source/src/lab/model/CollisionSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;For debugging, specify a function that will paint canvases, so that you can see the\nsimulation while stepping thru with debugger.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#setDebugPaint&quot;]],null,[]],[],[]],[],null,[[&quot;fn&quot;,[null,null,null,null,null,[[[null,null,[null,null,[],[null,null,null,null,null,null,null,null,1]]],[null,null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;function that will paint canvases&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setDistanceTol&quot;,[null,396,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets distance tolerance to use to determine if an object is in contact with another\nobject&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#setDistanceTol&quot;]],null,[]],null,[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;distance tolerance to use to determine if an object is in\ncontact with another object&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setElasticity&quot;,[null,737,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the elasticity of all RigidBodys to this value.\nElasticity is used when calculating collisions; a value of 1.0 means perfectly\nelastic where the kinetic energy after collision is the same as before (extremely\nbouncy), while a value of 0 means no elasticity (no bounce).\nBroadcasts a &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#module$exports$myphysicslab$lab$engine2D$ContactSim.ELASTICITY_SET\&quot;&gt;&lt;code&gt;#ELASTICITY_SET&lt;/code&gt;&lt;/a&gt; event. See &lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBody.html#setElasticity\&quot;&gt;&lt;code&gt;RigidBody#setElasticity&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#setElasticity&quot;]],null,[]],null,[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;elasticity to set on all RigidBodys, a number from 0 to 1.&lt;/p&gt;\n&quot;]]]]],null,[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if there are no RigidBodys&lt;/p&gt;\n&quot;]]]]]],[[&quot;setExtraAccel&quot;,[null,355,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the method to use for calculating extra acceleration added to\neliminate small amount of remaining velocity at a contact.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.ExtraAccel&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ExtraAccel.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the method to use for\ncalculating extra acceleration, from &lt;a href=\&quot;myphysicslab.lab.engine2D.ExtraAccel.html\&quot;&gt;&lt;code&gt;ExtraAccel&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setExtraAccelTimeStep&quot;,[null,368,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the approximate length of a time step, used to find extra acceleration needed\nto keep contact points at the proper distance apart.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the approximate length of a time step&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setPotentialEnergy&quot;,[null,35,null,[null,null,&quot;source/src/lab/model/EnergySystem.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the current potential energy of this system.&lt;/p&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#setPotentialEnergy&quot;]],null,[]],[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the current potential energy of this system&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setRandomSeed&quot;,[null,329,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the seed of the pseudo random number generator (RNG) used in this\nsimulation. The RNG is used during collision handling and contact force calculation. To\nget reproducible results, set this seed at the start of a simulation, and the RNG will\nthen always give the same sequence of random numbers.\nSee &lt;a href=\&quot;myphysicslab.lab.util.Random.html\&quot;&gt;&lt;code&gt;Random&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#setRandomSeed&quot;]],null,[]],null,[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the seed of the pseudo random number generator&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setShowCollisions&quot;,[null,446,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets whether to show collisions visually. Note that &lt;a href=\&quot;myphysicslab.lab.engine2D.ContactSim.html#setShowForces\&quot;&gt;&lt;code&gt;#setShowForces&lt;/code&gt;&lt;/a&gt;\nwill also change whether to show collisions.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#setShowCollisions&quot;]],null,[]],null,[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether to show collisions visually.&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setShowForces&quot;,[null,427,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets whether to add Forces to the SimList so they can be seen.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#setShowForces&quot;]],null,[]],[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#setShowForces&quot;]],null,[]],[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether to add Forces to the SimList so they can be seen&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setSimRect&quot;,[null,311,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the suggested size for the SimView. This is mainly for tests to communicate\nwith &lt;code&gt;myphysicslab.test.TestViewerApp&lt;/code&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#setSimRect&quot;]],null,[]],null,[],[]],[],null,[[&quot;rect&quot;,[null,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.util.DoubleRect&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.DoubleRect.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;the suggested size for the SimView&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;setVelocityTol&quot;,[null,418,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets velocity tolerance to use to determine if an object is in contact with another\nobject&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#setVelocityTol&quot;]],null,[]],null,[],[]],[],null,[[&quot;value&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;velocity tolerance to use to determine if an object is in\ncontact with another object&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;toString&quot;,[null,237,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#toString&quot;]],null,[]],[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html#toString&quot;]],null,[]],[],[]],[],null,[],[null,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[]],[[&quot;toStringShort&quot;,[null,42,null,[null,null,&quot;source/src/lab/util/Printable.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns a minimal string representation of this object, usually giving just identity\ninformation like the class name and name of the object.&lt;/p&gt;\n&lt;p&gt;For an object whose main purpose is to represent another Printable object, it is\nrecommended to include the result of calling &lt;code&gt;toStringShort&lt;/code&gt; on that other object. For\nexample, calling &lt;code&gt;toStringShort()&lt;/code&gt; on a DisplayShape might return something like\nthis:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;DisplayShape{polygon:Polygon{&amp;#39;chain3&amp;#39;}}\n&lt;/code&gt;&lt;/pre&gt;\n&quot;]]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#toStringShort&quot;]],null,[]],[],[]],[],null,[],[null,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;a minimal string representation of this object.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;toString_&quot;,[null,330,null,[null,null,&quot;source/src/lab/engine2D/ContactSim.js.src.html&quot;]],[[]],null,null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#toString_&quot;]],null,[]],[],[],[null,1]],[],null,[],[null,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[]]],[[[&quot;bods_&quot;,[null,148,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;The Polygons in this simulation.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#bods_&quot;]],null,[]],null,[],[],[null,1]],[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.engine2D.Polygon&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Polygon.html&quot;]],null,[]]]]]]],[[&quot;collisionAccuracy_&quot;,[null,254,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;How close in space we need to be to a collision, to decide to handle it,\nas a percentage of the targetGap &amp;#61; distanceTol/2.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#collisionAccuracy_&quot;]],null,[]],null,[],[],[null,1]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;debugPaint_&quot;,[null,308,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Function to paint canvases, for debugging.  If defined, this will be called within\n&lt;code&gt;moveObjects()&lt;/code&gt; so you can see the simulation state after each\ntime step (you will need to arrange your debugger to pause after\neach invocation of debugPaint_ to see the state).&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#debugPaint_&quot;]],null,[]],[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#debugPaint_&quot;]],null,[]],[],[],[null,1]],[null,null,null,null,null,[[[null,null,[null,null,[],[null,null,null,null,null,null,null,null,1]]],[null,null,null,null,null,null,null,null,null,1]]]]],[[&quot;forceLaws_&quot;,[null,158,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;The ForceLaws in this simulation.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#forceLaws_&quot;]],null,[]],null,[],[],[null,1]],[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;myphysicslab.lab.model.ForceLaw&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.ForceLaw.html&quot;]],null,[]]]]]]],[[&quot;showForces_&quot;,[null,153,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Whether to add Forces to the SimList so they can be seen.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#showForces_&quot;]],null,[]],null,[],[],[null,1]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;simList_&quot;,[null,169,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;The SimList holds SimObjects so they can be made visible.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#simList_&quot;]],null,[]],null,[],[],[null,1]],[null,null,null,[&quot;myphysicslab.lab.model.SimList&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.SimList.html&quot;]],null,[]]]],[[&quot;simRNG_&quot;,[null,231,null,[null,null,&quot;source/src/lab/engine2D/ImpulseSim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;The pseudo random number generator, used in collision handling and\ncomputing forces.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html#simRNG_&quot;]],null,[]],null,[],[],[null,1]],[null,null,null,[&quot;myphysicslab.lab.util.Random&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Random.html&quot;]],null,[]]]],[[&quot;simRect_&quot;,[null,164,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Suggested size for the SimView.  This is mainly for tests to communicate\nwith TestViewerApp.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#simRect_&quot;]],null,[]],null,[],[],[null,1]],[null,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.util.DoubleRect&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.DoubleRect.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,null,1]]]]],[[&quot;varsList_&quot;,[null,187,null,[null,null,&quot;source/src/lab/engine2D/RigidBodySim.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;The variables that determine the state of the simulation; there are six\nvariables for each RigidBody, plus some others for time, energy, etc.&lt;/p&gt;\n&quot;]]],null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html#varsList_&quot;]],null,[]],null,[],[],[null,1]],[null,null,null,[&quot;myphysicslab.lab.model.VarsList&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.VarsList.html&quot;]],null,[]]]]],null,[[&quot;myphysicslab.lab.engine2D.ImpulseSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ImpulseSim.html&quot;]],null,[]],[&quot;myphysicslab.lab.engine2D.RigidBodySim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodySim.html&quot;]],null,[]],[&quot;myphysicslab.lab.util.AbstractSubject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.AbstractSubject.html&quot;]],null,[]]],[[&quot;myphysicslab.lab.engine2D.DebugEngine2D&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.DebugEngine2D.html&quot;]],null,[]],[&quot;myphysicslab.lab.model.CollisionSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.CollisionSim.html&quot;]],null,[]],[&quot;myphysicslab.lab.model.EnergySystem&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.EnergySystem.html&quot;]],null,[]],[&quot;myphysicslab.lab.model.ODESim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.ODESim.html&quot;]],null,[]],[&quot;myphysicslab.lab.model.Simulation&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Simulation.html&quot;]],null,[]],[&quot;myphysicslab.lab.util.Printable&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Printable.html&quot;]],null,[]],[&quot;myphysicslab.lab.util.Subject&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Subject.html&quot;]],null,[]]],[],[[&quot;myphysicslab.lab.engine2D.ContactSim&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ContactSim.html&quot;]],null,[]],null,1],null,&quot;myphysicslab.lab.engine2D.ContactSim.html&quot;,&quot;myphysicslab.lab.engine2D.ContactSim&quot;,[],[],[],[]]]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="dossier.js" defer></script>