<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>myphysicslab.lab.engine2D.ComputeForces</title><link href="dossier.css" rel="stylesheet" type="text/css"><script src="types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,[[[&quot;myphysicslab.lab.engine2D.ComputeForces&quot;,null,null,null,[null,271,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],null,[[[null,&quot;&lt;p&gt;Computes forces at contact points between RigidBodys, or impulses at collision\npoints between RigidBodys. The &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#compute_forces\&quot;&gt;&lt;code&gt;#compute_forces&lt;/code&gt;&lt;/a&gt; method is an implementation of\nthe algorithm given in the paper&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;&lt;em&gt;Fast contact force computation for nonpenetrating rigid bodies&lt;/em&gt; by David Baraff,\nComputer Graphics Proceedings, Annual Conference Series: 23-34, 1994. 12 pages.&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;More info at:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;&lt;a href=\&quot;Engine2D.html\&quot;&gt;2D Physics Engine Overview&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;a href=\&quot;http://www.myphysicslab.com/contact.html\&quot;&gt;The Math and Physics Underlying ContactSim&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;myphysicslab.lab.engine2D.ContactSim&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;myphysicslab.lab.engine2D.ImpulseSim&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;This documentation is written assuming that &lt;em&gt;contact forces&lt;/em&gt; and resulting accelerations\nare being calculated, but everything applies equally when calculating multiple\nsimultaneous &lt;em&gt;collision impulses&lt;/em&gt; and resulting velocities.&lt;/p&gt;\n&lt;h3&gt;Terminology&lt;/h3&gt;\n&lt;p&gt;This documentation uses several terms from the Baraff paper, such as C, NC, Acc.\nSee that paper for precise definitions. Roughly these are:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;C is the set of contacts that have some force applied and zero acceleration&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;NC is the set of contacts that have no force applied because they are separating (they\nhave negative acceleration)&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;Acc is the subset of the A matrix corresponding to just the the set of contacts C&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;The algorithm starts with both C and NC being empty. We then examine one contact at a\ntime, moving it into C or NC, and possibly moving existing contacts between C and NC as\nnecessary.&lt;/p&gt;\n&lt;h3&gt;Constraints&lt;/h3&gt;\n&lt;p&gt;The acceleration of the gap distance at each contact point is given by&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a &amp;#61; A f &amp;#43; b\na &amp;#61; acceleration of the gap (positive means gap is tending to widen)\nA &amp;#61; n x n matrix where A[i,j] &amp;#61; change in acceleration at contact i resulting from\n  force of 1 being applied at contact j\nf &amp;#61; force applied at each contact (vector, length n)\nb &amp;#61; external and inertial forces in the system (vector, length n)\nn &amp;#61; number of contacts\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;We find forces such that&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;0 &amp;lt;&amp;#61; A f &amp;#43; b\nf . a &amp;#61; 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The first condition ensures that acceleration is non-negative, so that bodies are not\naccelerating into each other: contact forces can only push, never pull. The second\ncondition means that either&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;the force at a contact is zero and acceleration is positive (contacts are separating),\nor&lt;/li&gt;&lt;li&gt;the force at a contact is positive and acceleration is zero&lt;/li&gt;&lt;/ul&gt;\n&lt;h3&gt;Joints&lt;/h3&gt;\n&lt;p&gt;Joints are contact points that can both push and pull, and which never break their\ncontact. Regular contact points can only push, and the contact is broken if the\nobjects move apart. Joints are called &amp;#39;bilateral constraints&amp;#39; in the Baraff paper.&lt;/p&gt;\n&lt;p&gt;Joints have different constraints: the force can be be positive or negative, but the\nacceleration is always exactly zero.&lt;/p&gt;\n&lt;h3&gt;Return Value&lt;/h3&gt;\n&lt;p&gt;The return value from &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#compute_forces\&quot;&gt;&lt;code&gt;#compute_forces&lt;/code&gt;&lt;/a&gt; is -1 if successful, meaning that a set of\nforces were found so that the acceleration satisfies the above constraints. If not\nsuccessful, the caller can check the set of forces that were calculated to see if the\nresulting acceleration at each contact point is still acceptable.&lt;/p&gt;\n&lt;p&gt;See the method &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.checkForceAccel\&quot;&gt;&lt;code&gt;#checkForceAccel&lt;/code&gt;&lt;/a&gt; for how to check the accelerations. For example,\nthe following code calculates and checks the acceleration from the calculated forces.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;var error &amp;#61; computeForces.compute_forces(A, f, b, joint, false, time);\nif (error !&amp;#61; -1) {\n  var accel &amp;#61; UtilEngine.matrixMultiply(A, f);\n  accel &amp;#61; UtilEngine.vectorAdd(accel, b);\n  if (!computeForces.checkForceAccel(1E-8, f, accel, joint)) {\n    throw new Error();\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;Redundant Contacts&lt;/h3&gt;\n&lt;p&gt;It can often happen that the set of contacts is &lt;strong&gt;redundant&lt;/strong&gt; in that pushing on one\ncontact leads the algorithm to increase forces at other contacts in such a way that\nthe push at that contact is negated, leading to no change in acceleration at that\ncontact. This means that we cannot independently set the acceleration at that contact.&lt;/p&gt;\n&lt;p&gt;This shows up mathematically as the Acc matrix being &amp;#39;poorly conditioned&amp;#39; or singular\nif we were to add that contact to C, with some row being a linear combination of other\nrows. (Condition number is a measure of how close a matrix is to being singular). Each\nrow of the matrix corresponds to a contact point. Another way to say the same thing is\nthat there is a linear combination of rows that equals the zero vector. Then any one\nof those rows is &amp;#39;redundant&amp;#39; (because it can be expressed as a linear combination of\nother rows).&lt;/p&gt;\n&lt;p&gt;Simulations where redundant contacts show up include: the Pile simulation where a\npile of rectangular blocks is resting on each other in a corner on the ground; and the\nDoNothingGrinder where the shuttle blocks are wedged between immoveable blocks.&lt;/p&gt;\n&lt;h3&gt;Deferred (Rejected) Contacts&lt;/h3&gt;\n&lt;p&gt;We avoid adding redundant contacts to C, to keep the Acc matrix non-singular as long as\npossible. When starting to drive a contact to zero acceleration, we first check to see\nif adding this contact to C will make Acc singular. If so, we &lt;strong&gt;defer&lt;/strong&gt; (also called\n** reject**) the contact, so the contact goes on a &lt;strong&gt;list of rejects&lt;/strong&gt; (the &lt;code&gt;R&lt;/code&gt; array)\nwhich are handled only after all other non-deferred contacts have been treated, and then\nonly if the acceleration at the deferred contact is large enough to worry about.&lt;/p&gt;\n&lt;p&gt;For the normal non-deferred contacts we have a limit on the acceptable acceleration of\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#SMALL_POSITIVE\&quot;&gt;&lt;code&gt;#SMALL_POSITIVE&lt;/code&gt;&lt;/a&gt;; but for deferred contacts, we have a different larger limit on\nthe acceptable acceleration of 100 times that amount. Here &amp;#39;acceptable&amp;#39; means whether\nthe overall solution is acceptable, so that the &lt;code&gt;compute_forces&lt;/code&gt; method can indicate\nsuccess in its return value.&lt;/p&gt;\n&lt;p&gt;There are some other ways for a contact to be &amp;#39;deferred&amp;#39; (or &amp;#39;rejected&amp;#39;). One is\nwhen moving a contact from NC to C. When that happens, we do the same kind of check of\nwhether the contact will make Acc singular, and if so we defer the contact.&lt;/p&gt;\n&lt;p&gt;Another way that a contact can be deferred is if we notice that a &amp;#39;zero step&amp;#39; was\nmade repeatedly at the same contact. Often when a contact moves from NC to C, the step\nsize is close to zero because the contact had zero acceleration. This is OK, but if we\nthen notice that the contact moves back from C to NC with another zero size step, we\ndefer that contact because this can lead to an infinite loop. Note that there can be\nintervening zero steps of other contacts; for example, contact A, then B, and then C\nall move from NC to C with zero size steps, then A moves back from C to NC with a zero\nstep -- we would defer contact A. But if any other the intervening steps (for B and C)\nwere non-zero size then we would not defer contact A.&lt;/p&gt;\n&lt;p&gt;Note that we can only defer a contact when it has zero force on it in the solution\nas calculated to date. This is because all contacts in C usually have some non-zero\nforce, and if you removed a contact from C without first reducing its force to zero\nthen the solution would no longer be balanced and the acceleration at other contacts\nin C would no longer be zero and contacts in NC might have negative acceleration.\nTherefore we can defer a contact &lt;code&gt;d&lt;/code&gt; before starting to drive it to zero acceleration,\nbecause it is not yet in C and has no force. But as soon as you start driving to zero,\nyou have committed to putting the contact &lt;code&gt;d&lt;/code&gt; into C because each step increases the\nforce at &lt;code&gt;d&lt;/code&gt;. We can defer any contact that is currently in NC because it has no force.\nIn the &amp;#39;zero step&amp;#39; case, we can defer the contact that is in C only if it has zero\nforce on it.&lt;/p&gt;\n&lt;h3&gt;Order of Treating Contacts&lt;/h3&gt;\n&lt;p&gt;The order in which we handle (or &amp;#39;treat&amp;#39;) contacts is important and can affect what\nsolution is found. The policy is set via the &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#setNextContactPolicy\&quot;&gt;&lt;code&gt;#setNextContactPolicy&lt;/code&gt;&lt;/a&gt;\nmethod. The default policy is &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_HYBRID\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_HYBRID&lt;/code&gt;&lt;/a&gt; which first\ntreats Joints in random order, and then non-Joints in the order defined by which has the\nmost negative acceleration.&lt;/p&gt;\n&lt;p&gt;There are three other contact order policies: &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_MIN_ACCEL\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_MIN_ACCEL&lt;/code&gt;&lt;/a&gt;,\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_RANDOM\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_RANDOM&lt;/code&gt;&lt;/a&gt;, &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_PRE_ORDERED\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_PRE_ORDERED&lt;/code&gt;&lt;/a&gt;. Some of these are used\nfor testing.&lt;/p&gt;\n&lt;h3&gt;Infinite Loop Detection&lt;/h3&gt;\n&lt;p&gt;There is a mechanism to detect infinite loops where a series of contacts keeps being\nrejected over and over. Part of the mechanism looks at whether any progress was made in\nthe latest step by seeing if the acceleration at the contacts has changed.&lt;/p&gt;\n&lt;p&gt;The details of the infinite loop detection are as follows: There is a second &amp;#39;reRejects&amp;#39;\nlist which contains twice-rejected contacts. If we try to treat a reject, but then\nreject it again, it goes into the reRejects list and is removed from the rejects list.\nWhen any progress is made, the reRejects go back to the rejects list to be treated\nagain. If the rejects list is exhausted without making any progress, then an infinite\nloop is detected, then we abandon the entire process, returning an error code. It is\nthen up to the caller to decide if the resulting solution is adequate or not.&lt;/p&gt;\n&lt;h3&gt;Sometimes Acc Becomes Singular&lt;/h3&gt;\n&lt;p&gt;Despite the effort to keep Acc non-singular, we sometimes need to treat a contact that\nwill make Acc singular because the contact has acceleration that is unacceptably large.\nIn most cases this &amp;#39;unacceptably large&amp;#39; acceleration is actually very small, like 1E-8\nwhere the limit is 1E-10.&lt;/p&gt;\n&lt;p&gt;This algorithm is able to still find a solution when Acc is\nsingular, but then the forces can &lt;strong&gt;become unreasonably large&lt;/strong&gt; in order to drive the\nacceleration to a small value. What seems to often happen is the following: we are\ndriving contact &lt;code&gt;d&lt;/code&gt; to zero even though it makes Acc singular (if &lt;code&gt;d&lt;/code&gt; were added to C) –\nthis happens when we are treating a previously deferred contact, and is towards the end\nof the process when all non-deferred contacts are in the solution. What usually happens\nis that some other contact immediately moves from C to NC and then the &lt;code&gt;Acc&amp;#43;d&lt;/code&gt; matrix\nbecomes non-singular, which is a good result.&lt;/p&gt;\n&lt;p&gt;This algorithm is able to find a solution as long as the &lt;code&gt;b&lt;/code&gt; vector is in the column\nspace of the A matrix. This shows up in two places: first, we use a method of solving\nthe matrix problem &lt;code&gt;A x &amp;#61; b&lt;/code&gt; that can deal with a singular matrix like this. Second, we\nwill see that when trying to drive a &amp;#39;redundant&amp;#39; contact to zero acceleration that the\n&lt;code&gt;delta_a&lt;/code&gt; (the change in acceleration from applying force at the contact) is zero;\nnormally this means that we cannot drive that contact to zero acceleration and would\nfail; but instead it typically is the case that the total acceleration at that contact\nis already zero (or close to zero) because we have driven the other contacts to zero,\nand the redundant contact is dependent on those.&lt;/p&gt;\n&lt;h3&gt;Will Not Find Minimal Forces&lt;/h3&gt;\n&lt;p&gt;This algorithm is not guaranteed to find the minimum set of forces that will satisfy the\nconstraints. Rather, the solution found (the set of forces) is sensitive to the order in\nwhich contacts are treated.&lt;/p&gt;\n&lt;p&gt;See &lt;code&gt;myphysicslab.lab.engine2D.test.UtilEngine_test&lt;/code&gt; for unit tests that use random\ncontact orderings; those tests show that the maximum force and the length of the force\nvector depends on the ordering, and also on the criteria for when a matrix is poorly\nconditioned (which affects when we defer treating a contact that would make the Acc\nmatrix poorly conditioned).&lt;/p&gt;\n&lt;h3&gt;Performance Tweaks&lt;/h3&gt;\n&lt;p&gt;ComputeForces keeps a matrix allocated that is reused, to avoid re-allocating a large\nmatrix which seems to be a performance bottleneck. Some of the matrix algorithms were\nmodified so that the matrix can be over-sized. Also we reuse several vectors between\ncalls to &lt;code&gt;compute_forces&lt;/code&gt;, to avoid reallocation.&lt;/p&gt;\n&lt;p&gt;This resulted in an 11% reduction in running time for the &lt;code&gt;pile_20_random_blocks&lt;/code&gt;\nperformance test.&lt;/p&gt;\n&lt;h3&gt;Future Improvements&lt;/h3&gt;\n&lt;p&gt;See &lt;a href=\&quot;Engine2D.html#futureimprovements\&quot;&gt;Future Improvements&lt;/a&gt; in 2D Physics Engine\nOverview.&lt;/p&gt;\n&lt;h3&gt;Remaining Mysteries&lt;/h3&gt;\n&lt;p&gt;There are two remaining &amp;#39;math mysteries&amp;#39; in &lt;code&gt;compute_forces&lt;/code&gt;:&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;\n&lt;p&gt;When we go to drive a redundant contact &lt;code&gt;d&lt;/code&gt; to zero, it pushes a contact from C to\nNC, so that &lt;code&gt;d&lt;/code&gt; can be added and Acc stays non-singular. Is that guaranteed somehow?&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;When unreasonably large forces are calculated, it looks like it’s usually because\nthere is a pair of opposed contacts and somehow choosing the order so that these are\ntreated close together (in the sequence of which contact to treat when) is what causes a\nlarge force to occur. Is there a way to recognize this and avoid it? Perhaps the two\ncontacts are close to linearly dependent? Or maybe adding the second makes the condition\nof Acc bad?&lt;/p&gt;\n&lt;/li&gt;&lt;/ol&gt;\n&quot;]]],[null,null,null,null,null,1],null,[],null,[[[&quot;checkForceAccel&quot;,[null,988,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns true if the given force and accel vectors satisfy the constraints that if\n&lt;code&gt;f !&amp;#61; 0&lt;/code&gt; then &lt;code&gt;a &amp;#61; 0&lt;/code&gt;, or if &lt;code&gt;f &amp;#61; 0&lt;/code&gt; then &lt;code&gt;a &amp;gt;&amp;#61; 0&lt;/code&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;tolerance&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;ignore deviations from constraints smaller than this&lt;/p&gt;\n&quot;]]]],[&quot;force&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;array of forces applied to a set of contacts&lt;/p&gt;\n&quot;]]]],[&quot;accel&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;array of accelerations at a set of contacts&lt;/p&gt;\n&quot;]]]],[&quot;joint&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;whether each contact is a joint&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if the force and accel vectors satisfy the constraints&lt;/p&gt;\n&quot;]]]],[]],[[&quot;maxAccel&quot;,[null,734,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the maximum unwanted acceleration at all contacts.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;accel&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;acceleration at each contact&lt;/p&gt;\n&quot;]]]],[&quot;joint&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;true when contact is a Joint&lt;/p&gt;\n&quot;]]]],[&quot;n&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;number of contacts&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the maximum unwanted acceleration at all contacts&lt;/p&gt;\n&quot;]]]],[]]],[[[&quot;NEXT_CONTACT_HYBRID&quot;,[null,1901,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Constant indicates the &lt;strong&gt;Next Contact Policy&lt;/strong&gt; which chooses the contact with the\nmost negative acceleration, except Joints are treated first in random order.&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;NEXT_CONTACT_MIN_ACCEL&quot;,[null,1882,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Constant indicates the &lt;strong&gt;Next Contact Policy&lt;/strong&gt; which chooses the contact with the\nmost negative acceleration, treating Joints first.&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;NEXT_CONTACT_PRE_ORDERED&quot;,[null,1895,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Constant indicates the &lt;strong&gt;Next Contact Policy&lt;/strong&gt; which chooses contacts according to a\npre-arranged ordering given by the &amp;#39;preOrder&amp;#39; list of contact numbers, but treats Joints\nfirst.&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;NEXT_CONTACT_RANDOM&quot;,[null,1888,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Constant indicates the &lt;strong&gt;Next Contact Policy&lt;/strong&gt; which chooses contacts in random\norder, but treats Joints first.&lt;/p&gt;\n&quot;]]],null,null,[1],null,null,[],[]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]]],[[&quot;ComputeForces&quot;,[null,271,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Computes forces at contact points between RigidBodys, or impulses at collision\npoints between RigidBodys. The &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#compute_forces\&quot;&gt;&lt;code&gt;#compute_forces&lt;/code&gt;&lt;/a&gt; method is an implementation of\nthe algorithm given in the paper&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;&lt;em&gt;Fast contact force computation for nonpenetrating rigid bodies&lt;/em&gt; by David Baraff,\nComputer Graphics Proceedings, Annual Conference Series: 23-34, 1994. 12 pages.&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;More info at:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;&lt;a href=\&quot;Engine2D.html\&quot;&gt;2D Physics Engine Overview&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;a href=\&quot;http://www.myphysicslab.com/contact.html\&quot;&gt;The Math and Physics Underlying ContactSim&lt;/a&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;myphysicslab.lab.engine2D.ContactSim&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;&lt;code&gt;myphysicslab.lab.engine2D.ImpulseSim&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;This documentation is written assuming that &lt;em&gt;contact forces&lt;/em&gt; and resulting accelerations\nare being calculated, but everything applies equally when calculating multiple\nsimultaneous &lt;em&gt;collision impulses&lt;/em&gt; and resulting velocities.&lt;/p&gt;\n&lt;h3&gt;Terminology&lt;/h3&gt;\n&lt;p&gt;This documentation uses several terms from the Baraff paper, such as C, NC, Acc.\nSee that paper for precise definitions. Roughly these are:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;C is the set of contacts that have some force applied and zero acceleration&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;NC is the set of contacts that have no force applied because they are separating (they\nhave negative acceleration)&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;Acc is the subset of the A matrix corresponding to just the the set of contacts C&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;The algorithm starts with both C and NC being empty. We then examine one contact at a\ntime, moving it into C or NC, and possibly moving existing contacts between C and NC as\nnecessary.&lt;/p&gt;\n&lt;h3&gt;Constraints&lt;/h3&gt;\n&lt;p&gt;The acceleration of the gap distance at each contact point is given by&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;a &amp;#61; A f &amp;#43; b\na &amp;#61; acceleration of the gap (positive means gap is tending to widen)\nA &amp;#61; n x n matrix where A[i,j] &amp;#61; change in acceleration at contact i resulting from\n  force of 1 being applied at contact j\nf &amp;#61; force applied at each contact (vector, length n)\nb &amp;#61; external and inertial forces in the system (vector, length n)\nn &amp;#61; number of contacts\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;We find forces such that&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;0 &amp;lt;&amp;#61; A f &amp;#43; b\nf . a &amp;#61; 0\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;The first condition ensures that acceleration is non-negative, so that bodies are not\naccelerating into each other: contact forces can only push, never pull. The second\ncondition means that either&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;the force at a contact is zero and acceleration is positive (contacts are separating),\nor&lt;/li&gt;&lt;li&gt;the force at a contact is positive and acceleration is zero&lt;/li&gt;&lt;/ul&gt;\n&lt;h3&gt;Joints&lt;/h3&gt;\n&lt;p&gt;Joints are contact points that can both push and pull, and which never break their\ncontact. Regular contact points can only push, and the contact is broken if the\nobjects move apart. Joints are called &amp;#39;bilateral constraints&amp;#39; in the Baraff paper.&lt;/p&gt;\n&lt;p&gt;Joints have different constraints: the force can be be positive or negative, but the\nacceleration is always exactly zero.&lt;/p&gt;\n&lt;h3&gt;Return Value&lt;/h3&gt;\n&lt;p&gt;The return value from &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#compute_forces\&quot;&gt;&lt;code&gt;#compute_forces&lt;/code&gt;&lt;/a&gt; is -1 if successful, meaning that a set of\nforces were found so that the acceleration satisfies the above constraints. If not\nsuccessful, the caller can check the set of forces that were calculated to see if the\nresulting acceleration at each contact point is still acceptable.&lt;/p&gt;\n&lt;p&gt;See the method &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.checkForceAccel\&quot;&gt;&lt;code&gt;#checkForceAccel&lt;/code&gt;&lt;/a&gt; for how to check the accelerations. For example,\nthe following code calculates and checks the acceleration from the calculated forces.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;var error &amp;#61; computeForces.compute_forces(A, f, b, joint, false, time);\nif (error !&amp;#61; -1) {\n  var accel &amp;#61; UtilEngine.matrixMultiply(A, f);\n  accel &amp;#61; UtilEngine.vectorAdd(accel, b);\n  if (!computeForces.checkForceAccel(1E-8, f, accel, joint)) {\n    throw new Error();\n  }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3&gt;Redundant Contacts&lt;/h3&gt;\n&lt;p&gt;It can often happen that the set of contacts is &lt;strong&gt;redundant&lt;/strong&gt; in that pushing on one\ncontact leads the algorithm to increase forces at other contacts in such a way that\nthe push at that contact is negated, leading to no change in acceleration at that\ncontact. This means that we cannot independently set the acceleration at that contact.&lt;/p&gt;\n&lt;p&gt;This shows up mathematically as the Acc matrix being &amp;#39;poorly conditioned&amp;#39; or singular\nif we were to add that contact to C, with some row being a linear combination of other\nrows. (Condition number is a measure of how close a matrix is to being singular). Each\nrow of the matrix corresponds to a contact point. Another way to say the same thing is\nthat there is a linear combination of rows that equals the zero vector. Then any one\nof those rows is &amp;#39;redundant&amp;#39; (because it can be expressed as a linear combination of\nother rows).&lt;/p&gt;\n&lt;p&gt;Simulations where redundant contacts show up include: the Pile simulation where a\npile of rectangular blocks is resting on each other in a corner on the ground; and the\nDoNothingGrinder where the shuttle blocks are wedged between immoveable blocks.&lt;/p&gt;\n&lt;h3&gt;Deferred (Rejected) Contacts&lt;/h3&gt;\n&lt;p&gt;We avoid adding redundant contacts to C, to keep the Acc matrix non-singular as long as\npossible. When starting to drive a contact to zero acceleration, we first check to see\nif adding this contact to C will make Acc singular. If so, we &lt;strong&gt;defer&lt;/strong&gt; (also called\n** reject**) the contact, so the contact goes on a &lt;strong&gt;list of rejects&lt;/strong&gt; (the &lt;code&gt;R&lt;/code&gt; array)\nwhich are handled only after all other non-deferred contacts have been treated, and then\nonly if the acceleration at the deferred contact is large enough to worry about.&lt;/p&gt;\n&lt;p&gt;For the normal non-deferred contacts we have a limit on the acceptable acceleration of\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#SMALL_POSITIVE\&quot;&gt;&lt;code&gt;#SMALL_POSITIVE&lt;/code&gt;&lt;/a&gt;; but for deferred contacts, we have a different larger limit on\nthe acceptable acceleration of 100 times that amount. Here &amp;#39;acceptable&amp;#39; means whether\nthe overall solution is acceptable, so that the &lt;code&gt;compute_forces&lt;/code&gt; method can indicate\nsuccess in its return value.&lt;/p&gt;\n&lt;p&gt;There are some other ways for a contact to be &amp;#39;deferred&amp;#39; (or &amp;#39;rejected&amp;#39;). One is\nwhen moving a contact from NC to C. When that happens, we do the same kind of check of\nwhether the contact will make Acc singular, and if so we defer the contact.&lt;/p&gt;\n&lt;p&gt;Another way that a contact can be deferred is if we notice that a &amp;#39;zero step&amp;#39; was\nmade repeatedly at the same contact. Often when a contact moves from NC to C, the step\nsize is close to zero because the contact had zero acceleration. This is OK, but if we\nthen notice that the contact moves back from C to NC with another zero size step, we\ndefer that contact because this can lead to an infinite loop. Note that there can be\nintervening zero steps of other contacts; for example, contact A, then B, and then C\nall move from NC to C with zero size steps, then A moves back from C to NC with a zero\nstep -- we would defer contact A. But if any other the intervening steps (for B and C)\nwere non-zero size then we would not defer contact A.&lt;/p&gt;\n&lt;p&gt;Note that we can only defer a contact when it has zero force on it in the solution\nas calculated to date. This is because all contacts in C usually have some non-zero\nforce, and if you removed a contact from C without first reducing its force to zero\nthen the solution would no longer be balanced and the acceleration at other contacts\nin C would no longer be zero and contacts in NC might have negative acceleration.\nTherefore we can defer a contact &lt;code&gt;d&lt;/code&gt; before starting to drive it to zero acceleration,\nbecause it is not yet in C and has no force. But as soon as you start driving to zero,\nyou have committed to putting the contact &lt;code&gt;d&lt;/code&gt; into C because each step increases the\nforce at &lt;code&gt;d&lt;/code&gt;. We can defer any contact that is currently in NC because it has no force.\nIn the &amp;#39;zero step&amp;#39; case, we can defer the contact that is in C only if it has zero\nforce on it.&lt;/p&gt;\n&lt;h3&gt;Order of Treating Contacts&lt;/h3&gt;\n&lt;p&gt;The order in which we handle (or &amp;#39;treat&amp;#39;) contacts is important and can affect what\nsolution is found. The policy is set via the &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#setNextContactPolicy\&quot;&gt;&lt;code&gt;#setNextContactPolicy&lt;/code&gt;&lt;/a&gt;\nmethod. The default policy is &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_HYBRID\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_HYBRID&lt;/code&gt;&lt;/a&gt; which first\ntreats Joints in random order, and then non-Joints in the order defined by which has the\nmost negative acceleration.&lt;/p&gt;\n&lt;p&gt;There are three other contact order policies: &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_MIN_ACCEL\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_MIN_ACCEL&lt;/code&gt;&lt;/a&gt;,\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_RANDOM\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_RANDOM&lt;/code&gt;&lt;/a&gt;, &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_PRE_ORDERED\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_PRE_ORDERED&lt;/code&gt;&lt;/a&gt;. Some of these are used\nfor testing.&lt;/p&gt;\n&lt;h3&gt;Infinite Loop Detection&lt;/h3&gt;\n&lt;p&gt;There is a mechanism to detect infinite loops where a series of contacts keeps being\nrejected over and over. Part of the mechanism looks at whether any progress was made in\nthe latest step by seeing if the acceleration at the contacts has changed.&lt;/p&gt;\n&lt;p&gt;The details of the infinite loop detection are as follows: There is a second &amp;#39;reRejects&amp;#39;\nlist which contains twice-rejected contacts. If we try to treat a reject, but then\nreject it again, it goes into the reRejects list and is removed from the rejects list.\nWhen any progress is made, the reRejects go back to the rejects list to be treated\nagain. If the rejects list is exhausted without making any progress, then an infinite\nloop is detected, then we abandon the entire process, returning an error code. It is\nthen up to the caller to decide if the resulting solution is adequate or not.&lt;/p&gt;\n&lt;h3&gt;Sometimes Acc Becomes Singular&lt;/h3&gt;\n&lt;p&gt;Despite the effort to keep Acc non-singular, we sometimes need to treat a contact that\nwill make Acc singular because the contact has acceleration that is unacceptably large.\nIn most cases this &amp;#39;unacceptably large&amp;#39; acceleration is actually very small, like 1E-8\nwhere the limit is 1E-10.&lt;/p&gt;\n&lt;p&gt;This algorithm is able to still find a solution when Acc is\nsingular, but then the forces can &lt;strong&gt;become unreasonably large&lt;/strong&gt; in order to drive the\nacceleration to a small value. What seems to often happen is the following: we are\ndriving contact &lt;code&gt;d&lt;/code&gt; to zero even though it makes Acc singular (if &lt;code&gt;d&lt;/code&gt; were added to C) –\nthis happens when we are treating a previously deferred contact, and is towards the end\nof the process when all non-deferred contacts are in the solution. What usually happens\nis that some other contact immediately moves from C to NC and then the &lt;code&gt;Acc&amp;#43;d&lt;/code&gt; matrix\nbecomes non-singular, which is a good result.&lt;/p&gt;\n&lt;p&gt;This algorithm is able to find a solution as long as the &lt;code&gt;b&lt;/code&gt; vector is in the column\nspace of the A matrix. This shows up in two places: first, we use a method of solving\nthe matrix problem &lt;code&gt;A x &amp;#61; b&lt;/code&gt; that can deal with a singular matrix like this. Second, we\nwill see that when trying to drive a &amp;#39;redundant&amp;#39; contact to zero acceleration that the\n&lt;code&gt;delta_a&lt;/code&gt; (the change in acceleration from applying force at the contact) is zero;\nnormally this means that we cannot drive that contact to zero acceleration and would\nfail; but instead it typically is the case that the total acceleration at that contact\nis already zero (or close to zero) because we have driven the other contacts to zero,\nand the redundant contact is dependent on those.&lt;/p&gt;\n&lt;h3&gt;Will Not Find Minimal Forces&lt;/h3&gt;\n&lt;p&gt;This algorithm is not guaranteed to find the minimum set of forces that will satisfy the\nconstraints. Rather, the solution found (the set of forces) is sensitive to the order in\nwhich contacts are treated.&lt;/p&gt;\n&lt;p&gt;See &lt;code&gt;myphysicslab.lab.engine2D.test.UtilEngine_test&lt;/code&gt; for unit tests that use random\ncontact orderings; those tests show that the maximum force and the length of the force\nvector depends on the ordering, and also on the criteria for when a matrix is poorly\nconditioned (which affects when we defer treating a contact that would make the Acc\nmatrix poorly conditioned).&lt;/p&gt;\n&lt;h3&gt;Performance Tweaks&lt;/h3&gt;\n&lt;p&gt;ComputeForces keeps a matrix allocated that is reused, to avoid re-allocating a large\nmatrix which seems to be a performance bottleneck. Some of the matrix algorithms were\nmodified so that the matrix can be over-sized. Also we reuse several vectors between\ncalls to &lt;code&gt;compute_forces&lt;/code&gt;, to avoid reallocation.&lt;/p&gt;\n&lt;p&gt;This resulted in an 11% reduction in running time for the &lt;code&gt;pile_20_random_blocks&lt;/code&gt;\nperformance test.&lt;/p&gt;\n&lt;h3&gt;Future Improvements&lt;/h3&gt;\n&lt;p&gt;See &lt;a href=\&quot;Engine2D.html#futureimprovements\&quot;&gt;Future Improvements&lt;/a&gt; in 2D Physics Engine\nOverview.&lt;/p&gt;\n&lt;h3&gt;Remaining Mysteries&lt;/h3&gt;\n&lt;p&gt;There are two remaining &amp;#39;math mysteries&amp;#39; in &lt;code&gt;compute_forces&lt;/code&gt;:&lt;/p&gt;\n&lt;ol&gt;&lt;li&gt;\n&lt;p&gt;When we go to drive a redundant contact &lt;code&gt;d&lt;/code&gt; to zero, it pushes a contact from C to\nNC, so that &lt;code&gt;d&lt;/code&gt; can be added and Acc stays non-singular. Is that guaranteed somehow?&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;When unreasonably large forces are calculated, it looks like it’s usually because\nthere is a pair of opposed contacts and somehow choosing the order so that these are\ntreated close together (in the sequence of which contact to treat when) is what causes a\nlarge force to occur. Is there a way to recognize this and avoid it? Perhaps the two\ncontacts are close to linearly dependent? Or maybe adding the second makes the condition\nof Acc bad?&lt;/p&gt;\n&lt;/li&gt;&lt;/ol&gt;\n&quot;]]],null,null,[null,null,null,null,null,1],null,null,[],[]],[],1,[[&quot;name&quot;,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;for debugging, this distinguishes whether this is used for\ncontact forces or collision impulses&lt;/p&gt;\n&quot;]]]],[&quot;pRNG&quot;,[null,null,null,[&quot;myphysicslab.lab.util.Random&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Random.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;pseudo random number generator, used to\nrandomly decide order in which to calculate forces&lt;/p&gt;\n&quot;]]]],[&quot;tolerance&quot;,[1,null,null,null,null,[[[null,null,null,[&quot;number&quot;,null,null,1,[]]],[null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;used to decide when numbers are equal or zero;\ndefault is 1E-10&lt;/p&gt;\n&quot;]]]]],null,[]],[[[&quot;checkAccel&quot;,[null,926,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Check that acceleration at each contact is non-negative, for debug only.  Prints\ndebug information to console when errors are detected.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;tolerance&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;tolerance used for testing whether acceleration is\nnon-negative&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if acceleration is OK&lt;/p&gt;\n&quot;]]]],[]],[[&quot;compute_forces&quot;,[null,478,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Calculates the forces at each contact point of a multi-body contact situation.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;A&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;Float64Array&quot;,null,null,null,[]]]]]],[[[null,&quot;&lt;p&gt;an n x n matrix giving change in acceleration\nfor force at each contact&lt;/p&gt;\n&quot;]]]],[&quot;f&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;force at each contact (vector, length n),\nthis is what is solved for\nand is returned via this vector (this vector is zeroed out at start).&lt;/p&gt;\n&quot;]]]],[&quot;b&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;external and inertial forces in the system (vector, length n)&lt;/p&gt;\n&quot;]]]],[&quot;joint&quot;,[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]]]],[[[null,&quot;&lt;p&gt;indicates which contacts are Joints (vector, length n)&lt;/p&gt;\n&quot;]]]],[&quot;debug&quot;,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true shows debugging messages&lt;/p&gt;\n&quot;]]]],[&quot;time&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the current time, used only for debugging&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;error code, -1 if successful otherwise an error occurred&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getNextContactPolicy&quot;,[null,461,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the policy for choosing which contact to treat next.\nSee &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#setNextContactPolicy\&quot;&gt;&lt;code&gt;#setNextContactPolicy&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;One of &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_MIN_ACCEL\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_MIN_ACCEL&lt;/code&gt;&lt;/a&gt;,\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_RANDOM\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_RANDOM&lt;/code&gt;&lt;/a&gt;, &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_PRE_ORDERED\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_PRE_ORDERED&lt;/code&gt;&lt;/a&gt;,\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_HYBRID\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_HYBRID&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;\n&quot;]]]],[]],[[&quot;setNextContactPolicy&quot;,[null,449,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Sets the policy for choosing which contact to treat next.\nSee &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#getNextContactPolicy\&quot;&gt;&lt;code&gt;#getNextContactPolicy&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;nextContactPolicy&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;One of &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_MIN_ACCEL\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_MIN_ACCEL&lt;/code&gt;&lt;/a&gt;,\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_RANDOM\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_RANDOM&lt;/code&gt;&lt;/a&gt;, &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_PRE_ORDERED\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_PRE_ORDERED&lt;/code&gt;&lt;/a&gt;,\n&lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_HYBRID\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_HYBRID&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;\n&quot;]]]]],null,[]]],[[[&quot;WARNINGS&quot;,[null,327,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Print warnings about unusual conditions&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;order&quot;,[null,313,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Order in which contacts were treated; each entry is index of contact in A matrix&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]]],[[&quot;preOrder&quot;,[null,318,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Order in which treat contacts; each entry is index of contact in A matrix.\nSee &lt;a href=\&quot;myphysicslab.lab.engine2D.ComputeForces.html#module$exports$myphysicslab$lab$engine2D$ComputeForces.NEXT_CONTACT_PRE_ORDERED\&quot;&gt;&lt;code&gt;#NEXT_CONTACT_PRE_ORDERED&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[null,null,null,[&quot;Array&quot;,null,null,1,[[null,null,null,[&quot;number&quot;,null,null,1,[]]]]]]],[[&quot;specialCase&quot;,[null,435,null,[null,null,&quot;source/src/lab/engine2D/ComputeForces.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;to debug when special case detected&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]]],null,[],[],[],[[&quot;myphysicslab.lab.engine2D.ComputeForces&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ComputeForces.html&quot;]],null,[]],null,1],null,&quot;myphysicslab.lab.engine2D.ComputeForces.html&quot;,&quot;myphysicslab.lab.engine2D.ComputeForces&quot;,[],[],[],[]]]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="dossier.js" defer></script>