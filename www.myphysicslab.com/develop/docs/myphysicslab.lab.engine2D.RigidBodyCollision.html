<!DOCTYPE html><html lang="en" class="loading"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"><meta http-equiv="X-UA-Compatible" content="IE=edge"><link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><title>myphysicslab.lab.engine2D.RigidBodyCollision</title><link href="dossier.css" rel="stylesheet" type="text/css"><script src="types.js" defer></script><header><button class="dossier-menu"><i class="material-icons">menu</i></button><form><input type="search" placeholder="Search" tabindex="1"><i class="material-icons">search</i></form></header><nav class="dossier-nav"></nav><div class="content"><main data-page-data="[null,[[[&quot;myphysicslab.lab.engine2D.RigidBodyCollision&quot;,null,null,null,[null,211,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],null,[[[null,&quot;&lt;p&gt;RigidBodyCollision holds data related to a collision or resting contact between two\nRigidBodys.  The data includes:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;which RigidBodys are involved,&lt;/li&gt;&lt;li&gt;where the collision or contact point is,&lt;/li&gt;&lt;li&gt;what is the distance between the RigidBodys (negative means penetration),&lt;/li&gt;&lt;li&gt;what is the relative velocity at the collision point,&lt;/li&gt;&lt;li&gt;what is the normal vector at the collision point&lt;/li&gt;&lt;li&gt;when the collision was detected&lt;/li&gt;&lt;li&gt;the estimated time that the collision occurred&lt;/li&gt;&lt;li&gt;the force or impulse that is applied&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;Other data concerns the geometry of the bodies in relation to the collision point –\nthings like the curvature of the an edge, or distance from center of mass to the\ncollision point. Some data exists only for certain sub-classes of RigidBodyCollision.&lt;/p&gt;\n&lt;p&gt;Most of the data in RigidBodyCollision is filled in after it is created, but some data\nis updated as the collision handling process proceeds. Many of the fields (properties)\nof RigidBodyCollision are &amp;#39;package private&amp;#39; meaning that any code in the\n&lt;code&gt;myphysicslab.lab.engine2D&lt;/code&gt; package can modify the field directly. This avoids having to\nmake dozens of getter/setter methods for those fields.&lt;/p&gt;\n&lt;p&gt;See explanations at &lt;a href=\&quot;Engine2D.html\&quot;&gt;2D Physics Engine Overview&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;Terminology&lt;/h2&gt;\n&lt;img src=\&quot;RigidBodyCollision.svg\&quot; /&gt;\n&lt;p&gt;The two RigidBodys involved in the collision are referred to as follows:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;the &lt;strong&gt;&lt;em&gt;primary body&lt;/em&gt;&lt;/strong&gt;, has either a Vertex or Edge involved in the collision. For a\nConnector like Joint there is a connection point somewhere on the body instead of at a\nVertex or Edge.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;the &lt;strong&gt;&lt;em&gt;normal body&lt;/em&gt;&lt;/strong&gt;, has an Edge which defines the normal vector. For a Connector\nlike Joint, the normal is defined by the Connector not by an Edge.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;The &lt;strong&gt;&lt;em&gt;normal vector&lt;/em&gt;&lt;/strong&gt; is used to find the distance and velocity of the collision. The\ndistance between the bodies is measured in the direction of the normal vector.&lt;/p&gt;\n&lt;p&gt;The &lt;strong&gt;&lt;em&gt;normal relative velocity&lt;/em&gt;&lt;/strong&gt; is the velocity between the bodies at the point of\ncollision, but only in the direction of the normal vector.&lt;/p&gt;\n&lt;p&gt;The &lt;strong&gt;&lt;em&gt;R vector&lt;/em&gt;&lt;/strong&gt; goes from the center of mass to the &lt;strong&gt;&lt;em&gt;impact point&lt;/em&gt;&lt;/strong&gt;, on the\nprimary body. Similarly, the &lt;strong&gt;&lt;em&gt;R2 vector&lt;/em&gt;&lt;/strong&gt; is on the normal body from its center of\nmass to the impact point.&lt;/p&gt;\n&lt;h2&gt;Distance of Collision&lt;/h2&gt;\n&lt;p&gt;The point of collision, or &amp;#39;impact point&amp;#39;, is where the two bodies are touching or\npenetrating. This &amp;#39;point&amp;#39; is actually two different points, one on the primary body and\none on the normal body. Ideally at the moment of collision these are at the same point\nin space, but in practice they are always somewhat apart.&lt;/p&gt;\n&lt;p&gt;The distance between the two bodies is the distance between the two impact points in the\ndirection of the normal vector.  Mathematically we can define the distance as follows:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;p_a &amp;#61; point of impact on primary body\np_b &amp;#61; point of impact on normal body\nn &amp;#61; vector normal to edge at impact point\ndistance &amp;#61; n . (p_a - p_b)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If distance is positive there is a gap between the objects. If distance is negative,\nthen the objects are interpenetrating.&lt;/p&gt;\n&lt;h2&gt;Target Gap&lt;/h2&gt;\n&lt;p&gt;When bodies are interpenetrating, the physics engine gets &amp;#39;stuck&amp;#39;. To prevent this, we\naim to back up in time to a moment just before the collision when the objects are\nseparated by a small distance called the &lt;em&gt;target gap&lt;/em&gt;. See\n&lt;a href=\&quot;Engine2D.html#seektohalf-gapdistance\&quot;&gt;Seek to Half-Gap Distance&lt;/a&gt; for the full\nexplanation.&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;Collision.closeEnough&lt;/code&gt; method returns true when the collision distance is close to\nthe target gap distance, within the tolerance given by &lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html\&quot;&gt;&lt;code&gt;#getAccuracy&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;Collision Handling Notes TO BE EDITTED&lt;/h2&gt;\n&lt;p&gt;The following is actually super useful for reading the collision handling code&lt;/p&gt;\n&lt;p&gt;A colliding contact that might be handled comes in several flavors.\nAny contact exists in one of these zones, depending on its distance&lt;/p&gt;\n&lt;pre&gt;\n0. out of range.\n   distanceTol\n1. not yet in target accuracy zone.\n   targetGap&amp;#43;accuracy\n2. in target accuracy zone\n   targetGap-accuracy\n3. past target accuracy zone but not penetrating\n   zero distance\n4. penetrating (illegal)\n\n&amp;gt; contact: 1, 2, 3;  small velocity\n&amp;gt; isTouching(): 1, 2, 3;  any velocity\n&amp;gt;closeEnough(false): 2;  any velocity\n&amp;gt; closeEnough(true): 2 or 3;  any velocity\n&amp;gt; isColliding() 3 or 4 for large negative velocity;  4 for large positive velocity\n&amp;gt; illegalState(): 4  any velocity\n&lt;/pre&gt;\n&lt;p&gt;I also have some diagrams from around May 16, 2016 that makes the above very clear.&lt;/p&gt;\n&lt;h2&gt;Update State After Backing Up In Time&lt;/h2&gt;\n&lt;p&gt;The collision handling scheme used by &lt;code&gt;myphysicslab.lab.model.CollisionAdvance&lt;/code&gt;\nresults in backing up in time from the post-collision state to the pre-collision state.\nThis is done to avoid having RigidBodys being in an ambiguous illegal interpenetrating\nstate.&lt;/p&gt;\n&lt;p&gt;A consequence of this is that the RigidBodyCollision we are handling will have its data\nfrom the near-future post-collision state. The method &lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html#updateCollision\&quot;&gt;&lt;code&gt;#updateCollision&lt;/code&gt;&lt;/a&gt; updates\nthe RigidBodyCollision to reflect the current pre-collision state after backing up in\ntime.&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;mustHandle&lt;/code&gt; flag remembers those RigidBodyCollisions that were penetrating in the\npost-collision state, before the backup in time occurred. This is needed because those\nRigidBodyCollisions might otherwise indicate that they do not need to be handled: they\nhave negative distance (penetrating) in the post-collision state, but positive distance\n(non-penetrating) in the pre-collision state.&lt;/p&gt;\n&lt;h2&gt;The U Vector&lt;/h2&gt;\n&lt;p&gt;When a RigidBody has a curved edge involved in the collision, the &lt;code&gt;U&lt;/code&gt; vector is vector\nfrom body&amp;#39;s center of mass to center of the circular edge. For the primary body this is\ncalled the &lt;code&gt;U&lt;/code&gt; vector, for the normal body it is called the &lt;code&gt;U2&lt;/code&gt; vector.&lt;/p&gt;\n&lt;p&gt;For curved edges we use the &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;U2&lt;/code&gt; vectors instead of the &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt; vectors.&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;U2&lt;/code&gt; vectors are used in finding the contact force needed because a smooth\ncurved edge works differently than a sharp pointed corner. The normal distance (and\ntherefore normal velocity) between a straight edge and a circle is related to the\nmovement of the circle&amp;#39;s center – rotation of the circle about the center is irrelevant.\nThis is different to a sharp corner where the movement of the point of the corner is\nwhat is important.&lt;/p&gt;\n&lt;p&gt;This is relevant for finding contact forces which are applied over time. For an\ninstantaneous collision impulse this is not important because the bodies immediately\nmove apart.&lt;/p&gt;\n&lt;p&gt;See the paper &lt;a href=\&quot;CEP_Curved_Edge_Physics.pdf\&quot;&gt;Curved Edge Physics paper&lt;/a&gt; by Erik Neumann\nfor modifications to contact forces when curved edges are involved.&lt;/p&gt;\n&lt;p&gt;&lt;a id=\&quot;equivalenceofusingroruvector\&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;h2&gt;Equivalence of Using R or U Vector For Normal Velocity&lt;/h2&gt;\n&lt;p&gt;Here we show that you get the same result whether using the R or U vector in\n&lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html#getNormalVelocity\&quot;&gt;&lt;code&gt;#getNormalVelocity&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Suppose you have a circular body striking a horizontal infinite mass floor; let the\ncircle have an offset center of mass, so that U and R are different.&lt;/p&gt;\n&lt;img src=\&quot;CEP_Equiv_U_R_Vectors.svg\&quot; /&gt;\n&lt;pre&gt;&lt;code&gt;vab &amp;#61; relative velocity of contact points (vpa, vpb) on bodies\nvab &amp;#61; (vpa - vpb)\nvpa &amp;#61; va &amp;#43; wa x ra &amp;#61; velocity of contact point\nvab &amp;#61; va &amp;#43; wa x ra - vb - wb x rb\n// vab.n &amp;#61; (va &amp;#43; wa x ra - vb - wb x rb) . n\n// cross product: w x r &amp;#61; (0,0,w) x (rx, ry, 0) &amp;#61; (-w*ry, w*rx, 0)\ndx &amp;#61; vax &amp;#43; wa*(-ray) - vbx - wb*(-rby);\ndy &amp;#61; vay &amp;#43; wa*(rax) - vby - wb*(rbx);\nnv &amp;#61; nx*dx &amp;#43; ny*dy;\nbut with n &amp;#61; (0, 1) we have\nnv &amp;#61; 0*dx &amp;#43; 1*dy &amp;#61; dy\nand because body b is infinite mass, we have vbx &amp;#61; vby &amp;#61; wb &amp;#61; 0, so\ndy &amp;#61; vay &amp;#43; wa*(rax)\ndy &amp;#61; vay &amp;#43; wa*(uax)   // when using U instead of R\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the picture, you can see that &lt;code&gt;rax &amp;#61; uax&lt;/code&gt;, because the normal at the impact\npoint goes thru the center of the circle, and so both U and R have the same &lt;code&gt;x&lt;/code&gt;\ncomponent. The situation would be the same when the normal is not &lt;code&gt;(0, 1)&lt;/code&gt;. In the\ngeneral case, you are finding the length of R (or U) that is orthogonal to the normal,\nand again these are the same for U and R because the normal at the impact point goes\nright thru the center of the circle.&lt;/p&gt;\n&quot;]]],[null,null,null,null,null,1],null,[],null,[],[],[[&quot;RigidBodyCollision&quot;,[null,211,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;RigidBodyCollision holds data related to a collision or resting contact between two\nRigidBodys.  The data includes:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;which RigidBodys are involved,&lt;/li&gt;&lt;li&gt;where the collision or contact point is,&lt;/li&gt;&lt;li&gt;what is the distance between the RigidBodys (negative means penetration),&lt;/li&gt;&lt;li&gt;what is the relative velocity at the collision point,&lt;/li&gt;&lt;li&gt;what is the normal vector at the collision point&lt;/li&gt;&lt;li&gt;when the collision was detected&lt;/li&gt;&lt;li&gt;the estimated time that the collision occurred&lt;/li&gt;&lt;li&gt;the force or impulse that is applied&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;Other data concerns the geometry of the bodies in relation to the collision point –\nthings like the curvature of the an edge, or distance from center of mass to the\ncollision point. Some data exists only for certain sub-classes of RigidBodyCollision.&lt;/p&gt;\n&lt;p&gt;Most of the data in RigidBodyCollision is filled in after it is created, but some data\nis updated as the collision handling process proceeds. Many of the fields (properties)\nof RigidBodyCollision are &amp;#39;package private&amp;#39; meaning that any code in the\n&lt;code&gt;myphysicslab.lab.engine2D&lt;/code&gt; package can modify the field directly. This avoids having to\nmake dozens of getter/setter methods for those fields.&lt;/p&gt;\n&lt;p&gt;See explanations at &lt;a href=\&quot;Engine2D.html\&quot;&gt;2D Physics Engine Overview&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;Terminology&lt;/h2&gt;\n&lt;img src=\&quot;RigidBodyCollision.svg\&quot; /&gt;\n&lt;p&gt;The two RigidBodys involved in the collision are referred to as follows:&lt;/p&gt;\n&lt;ul&gt;&lt;li&gt;\n&lt;p&gt;the &lt;strong&gt;&lt;em&gt;primary body&lt;/em&gt;&lt;/strong&gt;, has either a Vertex or Edge involved in the collision. For a\nConnector like Joint there is a connection point somewhere on the body instead of at a\nVertex or Edge.&lt;/p&gt;\n&lt;/li&gt;&lt;li&gt;\n&lt;p&gt;the &lt;strong&gt;&lt;em&gt;normal body&lt;/em&gt;&lt;/strong&gt;, has an Edge which defines the normal vector. For a Connector\nlike Joint, the normal is defined by the Connector not by an Edge.&lt;/p&gt;\n&lt;/li&gt;&lt;/ul&gt;\n&lt;p&gt;The &lt;strong&gt;&lt;em&gt;normal vector&lt;/em&gt;&lt;/strong&gt; is used to find the distance and velocity of the collision. The\ndistance between the bodies is measured in the direction of the normal vector.&lt;/p&gt;\n&lt;p&gt;The &lt;strong&gt;&lt;em&gt;normal relative velocity&lt;/em&gt;&lt;/strong&gt; is the velocity between the bodies at the point of\ncollision, but only in the direction of the normal vector.&lt;/p&gt;\n&lt;p&gt;The &lt;strong&gt;&lt;em&gt;R vector&lt;/em&gt;&lt;/strong&gt; goes from the center of mass to the &lt;strong&gt;&lt;em&gt;impact point&lt;/em&gt;&lt;/strong&gt;, on the\nprimary body. Similarly, the &lt;strong&gt;&lt;em&gt;R2 vector&lt;/em&gt;&lt;/strong&gt; is on the normal body from its center of\nmass to the impact point.&lt;/p&gt;\n&lt;h2&gt;Distance of Collision&lt;/h2&gt;\n&lt;p&gt;The point of collision, or &amp;#39;impact point&amp;#39;, is where the two bodies are touching or\npenetrating. This &amp;#39;point&amp;#39; is actually two different points, one on the primary body and\none on the normal body. Ideally at the moment of collision these are at the same point\nin space, but in practice they are always somewhat apart.&lt;/p&gt;\n&lt;p&gt;The distance between the two bodies is the distance between the two impact points in the\ndirection of the normal vector.  Mathematically we can define the distance as follows:&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;p_a &amp;#61; point of impact on primary body\np_b &amp;#61; point of impact on normal body\nn &amp;#61; vector normal to edge at impact point\ndistance &amp;#61; n . (p_a - p_b)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;If distance is positive there is a gap between the objects. If distance is negative,\nthen the objects are interpenetrating.&lt;/p&gt;\n&lt;h2&gt;Target Gap&lt;/h2&gt;\n&lt;p&gt;When bodies are interpenetrating, the physics engine gets &amp;#39;stuck&amp;#39;. To prevent this, we\naim to back up in time to a moment just before the collision when the objects are\nseparated by a small distance called the &lt;em&gt;target gap&lt;/em&gt;. See\n&lt;a href=\&quot;Engine2D.html#seektohalf-gapdistance\&quot;&gt;Seek to Half-Gap Distance&lt;/a&gt; for the full\nexplanation.&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;Collision.closeEnough&lt;/code&gt; method returns true when the collision distance is close to\nthe target gap distance, within the tolerance given by &lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html\&quot;&gt;&lt;code&gt;#getAccuracy&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;h2&gt;Collision Handling Notes TO BE EDITTED&lt;/h2&gt;\n&lt;p&gt;The following is actually super useful for reading the collision handling code&lt;/p&gt;\n&lt;p&gt;A colliding contact that might be handled comes in several flavors.\nAny contact exists in one of these zones, depending on its distance&lt;/p&gt;\n&lt;pre&gt;\n0. out of range.\n   distanceTol\n1. not yet in target accuracy zone.\n   targetGap&amp;#43;accuracy\n2. in target accuracy zone\n   targetGap-accuracy\n3. past target accuracy zone but not penetrating\n   zero distance\n4. penetrating (illegal)\n\n&amp;gt; contact: 1, 2, 3;  small velocity\n&amp;gt; isTouching(): 1, 2, 3;  any velocity\n&amp;gt;closeEnough(false): 2;  any velocity\n&amp;gt; closeEnough(true): 2 or 3;  any velocity\n&amp;gt; isColliding() 3 or 4 for large negative velocity;  4 for large positive velocity\n&amp;gt; illegalState(): 4  any velocity\n&lt;/pre&gt;\n&lt;p&gt;I also have some diagrams from around May 16, 2016 that makes the above very clear.&lt;/p&gt;\n&lt;h2&gt;Update State After Backing Up In Time&lt;/h2&gt;\n&lt;p&gt;The collision handling scheme used by &lt;code&gt;myphysicslab.lab.model.CollisionAdvance&lt;/code&gt;\nresults in backing up in time from the post-collision state to the pre-collision state.\nThis is done to avoid having RigidBodys being in an ambiguous illegal interpenetrating\nstate.&lt;/p&gt;\n&lt;p&gt;A consequence of this is that the RigidBodyCollision we are handling will have its data\nfrom the near-future post-collision state. The method &lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html#updateCollision\&quot;&gt;&lt;code&gt;#updateCollision&lt;/code&gt;&lt;/a&gt; updates\nthe RigidBodyCollision to reflect the current pre-collision state after backing up in\ntime.&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;mustHandle&lt;/code&gt; flag remembers those RigidBodyCollisions that were penetrating in the\npost-collision state, before the backup in time occurred. This is needed because those\nRigidBodyCollisions might otherwise indicate that they do not need to be handled: they\nhave negative distance (penetrating) in the post-collision state, but positive distance\n(non-penetrating) in the pre-collision state.&lt;/p&gt;\n&lt;h2&gt;The U Vector&lt;/h2&gt;\n&lt;p&gt;When a RigidBody has a curved edge involved in the collision, the &lt;code&gt;U&lt;/code&gt; vector is vector\nfrom body&amp;#39;s center of mass to center of the circular edge. For the primary body this is\ncalled the &lt;code&gt;U&lt;/code&gt; vector, for the normal body it is called the &lt;code&gt;U2&lt;/code&gt; vector.&lt;/p&gt;\n&lt;p&gt;For curved edges we use the &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;U2&lt;/code&gt; vectors instead of the &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;R2&lt;/code&gt; vectors.&lt;/p&gt;\n&lt;p&gt;The &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;U2&lt;/code&gt; vectors are used in finding the contact force needed because a smooth\ncurved edge works differently than a sharp pointed corner. The normal distance (and\ntherefore normal velocity) between a straight edge and a circle is related to the\nmovement of the circle&amp;#39;s center – rotation of the circle about the center is irrelevant.\nThis is different to a sharp corner where the movement of the point of the corner is\nwhat is important.&lt;/p&gt;\n&lt;p&gt;This is relevant for finding contact forces which are applied over time. For an\ninstantaneous collision impulse this is not important because the bodies immediately\nmove apart.&lt;/p&gt;\n&lt;p&gt;See the paper &lt;a href=\&quot;CEP_Curved_Edge_Physics.pdf\&quot;&gt;Curved Edge Physics paper&lt;/a&gt; by Erik Neumann\nfor modifications to contact forces when curved edges are involved.&lt;/p&gt;\n&lt;p&gt;&lt;a id=\&quot;equivalenceofusingroruvector\&quot;&gt;&lt;/a&gt;&lt;/p&gt;\n&lt;h2&gt;Equivalence of Using R or U Vector For Normal Velocity&lt;/h2&gt;\n&lt;p&gt;Here we show that you get the same result whether using the R or U vector in\n&lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html#getNormalVelocity\&quot;&gt;&lt;code&gt;#getNormalVelocity&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&lt;p&gt;Suppose you have a circular body striking a horizontal infinite mass floor; let the\ncircle have an offset center of mass, so that U and R are different.&lt;/p&gt;\n&lt;img src=\&quot;CEP_Equiv_U_R_Vectors.svg\&quot; /&gt;\n&lt;pre&gt;&lt;code&gt;vab &amp;#61; relative velocity of contact points (vpa, vpb) on bodies\nvab &amp;#61; (vpa - vpb)\nvpa &amp;#61; va &amp;#43; wa x ra &amp;#61; velocity of contact point\nvab &amp;#61; va &amp;#43; wa x ra - vb - wb x rb\n// vab.n &amp;#61; (va &amp;#43; wa x ra - vb - wb x rb) . n\n// cross product: w x r &amp;#61; (0,0,w) x (rx, ry, 0) &amp;#61; (-w*ry, w*rx, 0)\ndx &amp;#61; vax &amp;#43; wa*(-ray) - vbx - wb*(-rby);\ndy &amp;#61; vay &amp;#43; wa*(rax) - vby - wb*(rbx);\nnv &amp;#61; nx*dx &amp;#43; ny*dy;\nbut with n &amp;#61; (0, 1) we have\nnv &amp;#61; 0*dx &amp;#43; 1*dy &amp;#61; dy\nand because body b is infinite mass, we have vbx &amp;#61; vby &amp;#61; wb &amp;#61; 0, so\ndy &amp;#61; vay &amp;#43; wa*(rax)\ndy &amp;#61; vay &amp;#43; wa*(uax)   // when using U instead of R\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;In the picture, you can see that &lt;code&gt;rax &amp;#61; uax&lt;/code&gt;, because the normal at the impact\npoint goes thru the center of the circle, and so both U and R have the same &lt;code&gt;x&lt;/code&gt;\ncomponent. The situation would be the same when the normal is not &lt;code&gt;(0, 1)&lt;/code&gt;. In the\ngeneral case, you are finding the length of R (or U) that is orthogonal to the normal,\nand again these are the same for U and R because the normal at the impact point goes\nright thru the center of the circle.&lt;/p&gt;\n&quot;]]],null,null,[null,null,null,null,null,1],null,null,[],[]],[],1,[[&quot;body&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBody&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBody.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the &amp;#39;primary&amp;#39; body which typically has a Vertex or Edge\ninvolved in the collision&lt;/p&gt;\n&quot;]]]],[&quot;normalBody&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBody&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBody.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the &amp;#39;normal&amp;#39; body which typically has an Edge\ninvolved in the collision that defines the normal vector for the collision&lt;/p&gt;\n&quot;]]]],[&quot;joint&quot;,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether this is a bilateral constraint which can both\npush and pull.&lt;/p&gt;\n&quot;]]]]],null,[]],[[[&quot;bilateral&quot;,[null,405,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns true if this represents a bilateral constraint which can both push and\npull; for example a &lt;code&gt;myphysicslab.lab.engine2D.Joint&lt;/code&gt; between two objects.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#bilateral&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if this is a bilateral constraint&lt;/p&gt;\n&quot;]]]],[]],[[&quot;checkConsistent&quot;,[null,414,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Checks that the fields of this collision are consistent\nand obey policy.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[],null,[]],[[&quot;closeEnough&quot;,[null,441,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Whether close enough to the point when this Collision can be handled.\nThe &lt;code&gt;allowTiny&lt;/code&gt; parameter exists because of cases where a\nsmall distance collision cannot be backed-up in time to get near to the preferred\ntarget &amp;#39;half gap&amp;#39; distance.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#closeEnough&quot;]],null,[]]],[]],[],null,[[&quot;allowTiny&quot;,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;regard as &amp;#39;close enough&amp;#39; Collisions that have smaller\ndistance than distance accuracy would normally allow&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if close enough to the point when this Collision can be handled.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;contact&quot;,[null,462,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns true if this is a stable contact: the objects are touching but\nnot colliding.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#contact&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if this is a stable contact&lt;/p&gt;\n&quot;]]]],[]],[[&quot;distanceToHalfGap&quot;,[null,471,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns distance to the target &amp;#39;half gap&amp;#39; distance. We aim to handle a collision\nwhen the distance is &amp;#39;half gap&amp;#39;, which is when this returns zero.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;distance to the target &amp;#39;half gap&amp;#39; distance.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getClassName&quot;,[null,479,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns name of class of this object.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;string&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;name of class of this object.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getConnector&quot;,[null,487,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the Connector that generated this collision, or null if this collision\nwas not generated by a Connector.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[],[null,[null,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.engine2D.Connector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Connector.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;the Connector that generated this\ncollision, or null&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getDetectedTime&quot;,[null,492,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the simulation time when the Collision was detected.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#getDetectedTime&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the simulation time when the Collision was detected&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getDistance&quot;,[null,497,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the distance between the objects. Negative distance means\nthe objects are interpenetrating.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#getDistance&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the distance between the objects&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getElasticity&quot;,[null,507,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the elasticity used when calculating collisions; a value of 1.0 means\nperfect elasticity where the kinetic energy after collision is the same as before\n(extremely bouncy), while a value of 0 means no elasticity (no bounce). A collision\nuses the lesser elasticity value of the two bodies involved.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;elasticity used when calculating collisions, a number from 0 to 1.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getEstimatedTime&quot;,[null,512,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the estimated time when this Collision should be handled by firing an\nimpulse.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#getEstimatedTime&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the estimated time when this Collision should be handled or &lt;code&gt;NaN&lt;/code&gt; if\nunknown.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getImpact1&quot;,[null,520,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns point of impact on the primary body, in global coords.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;point of impact on the primary body, in global coords&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getImpact2&quot;,[null,530,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns point of impact on normal body, in global coords. For example, this is\nneeded for Rope because the impact points are far apart. Often null when only\n&lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html#getImpact1\&quot;&gt;&lt;code&gt;#getImpact1&lt;/code&gt;&lt;/a&gt; is needed.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[],[null,[null,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;point of impact on normal body, in global coords, or null&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getImpulse&quot;,[null,535,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns size of impulse that was applied to this Collision.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#getImpulse&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;size of impulse that was applied to this Collision, or NaN if no\nimpulse applied.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getLateralVelocity&quot;,[null,545,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;The lateral velocity (sideways to normal) between the two bodies at the point of\ncontact.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the lateral velocity (sideways to normal) between the two bodies\nat the point of contact.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getNormalBody&quot;,[null,558,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the normal body involved in the collision, which defines the normal vector.\nThe classic situation is that a vertex on the primary body is colliding into an edge\non the normal body, but there are many variations on this.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBody&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBody.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the normal body involved in the collision&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getNormalVelocity&quot;,[null,569,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the relative normal velocity based on current velocity of the\nbodies. Negative velocity means the objects moving towards each other,\npositive velocity means they are moving apart.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;relative normal velocity between the two bodies\nat the point of contact.&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getPrimaryBody&quot;,[null,602,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the primary body involved in the collision. The primary body does not\ndefine the normal.  The classic situation is that a vertex on the primary body is\ncolliding into an edge on the normal body, but there are many variations on this.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBody&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBody.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the primary body involved in the collision&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getR1&quot;,[null,582,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns vector from center of mass of primary body to point of impact,\nin world coords&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;vector from center of mass of primary body to point of impact,\nin world coords&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getR2&quot;,[null,591,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns vector from center of mass of normal body to point of impact,\nin world coords.  Uses the second impact point if appropriate.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;vector from center of mass of normal body to point of impact,\nin world coords&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getRelativeVelocity&quot;,[null,625,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the difference in velocity of the two impact points of the collision\nbased on current velocity of the bodies.&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;let V &amp;#61; velocity of center of mass (CM);\nlet R &amp;#61; distance vector CM to contact point\nlet w &amp;#61; angular velocity\nw x R &amp;#61; (0, 0, w) x (Rx, Ry, 0) &amp;#61; (-w Ry, w Rx, 0)\nvelocity of corner &amp;#61; V &amp;#43; w x R &amp;#61; (Vx - w Ry, Vy &amp;#43; w Rx, 0)\nrelative velocity &amp;#61; Vab &amp;#61; Va &amp;#43; wa x Ra - Vb - wb x Rb\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;For curved edge we use the &lt;code&gt;U&lt;/code&gt; vector (from center of mass to edge&amp;#39;s circle center)\ninstead of &lt;code&gt;R&lt;/code&gt; vector (from center of mass to point of impact). Because what matters is\nnot the motion of the individual point but instead the entire curved edge. Consider that\nfor a ball with center of mass at center of the circle, rotation doesn&amp;#39;t change the\ndistance at all.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the velocity vector of this collision&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getU1&quot;,[null,658,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns vector from center of mass of primary body to either point of impact\nor to center of circular edge in world coords.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;vector from center of mass of primary body to either point\nof impact or to center of circular edge in world coords&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getU2&quot;,[null,668,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns vector from center of mass of normal body to either point of impact\nor to center of circular edge in world coords. Uses the second impact point if\nappropriate.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;vector from center of mass of normal body to either point\nof impact or to center of circular edge, in world coords&lt;/p&gt;\n&quot;]]]],[]],[[&quot;getVelocity&quot;,[null,673,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns the relative normal velocity between the two collision points.\nNegative velocity means the objects are colliding, positive means they are separating.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#getVelocity&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;relative normal velocity between the two collision points,\nnegative means colliding&lt;/p&gt;\n&quot;]]]],[]],[[&quot;hasBody&quot;,[null,682,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Whether this collision involves the given RigidBody&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[[&quot;body&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBody&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBody.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the RigidBody of interest&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether collision involves the given RigidBody&lt;/p&gt;\n&quot;]]]],[]],[[&quot;hasEdge&quot;,[null,692,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Whether this collision involves the given edge.\nIf given edge is null, then always returns false.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[[&quot;edge&quot;,[null,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.engine2D.Edge&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Edge.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,null,1]]]],[[[null,&quot;&lt;p&gt;the Edge of interest&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether collision involves the given Edge&lt;/p&gt;\n&quot;]]]],[]],[[&quot;hasVertex&quot;,[null,701,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Whether this collision involves the given vertex&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[[&quot;v&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.Vertex&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.Vertex.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the Vertex of interest&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether collision involves the given Vertex&lt;/p&gt;\n&quot;]]]],[]],[[&quot;illegalState&quot;,[null,706,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns true if this represents an illegal state, typically because objects are\ninterpenetrating.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#illegalState&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if this represents an illegal state&lt;/p&gt;\n&quot;]]]],[]],[[&quot;isColliding&quot;,[null,714,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns true if this represents a collision state, generally when two objects are\ninterpenetrating. The collision search mechanism implemented by\n&lt;code&gt;myphysicslab.lab.model.AdvanceStrategy#advance&lt;/code&gt; operates to set the simulation at a time\nvery close to but just before any Collision is happening, see &lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html#getEstimatedTime\&quot;&gt;&lt;code&gt;#getEstimatedTime&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#isColliding&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;&lt;code&gt;true&lt;/code&gt; if this represents a collision state&lt;/p&gt;\n&quot;]]]],[]],[[&quot;isTouching&quot;,[null,730,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Whether the distance is small enough that the objects are touching each other\nso that impulses can be transmitted.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#isTouching&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;whether the objects are touching each other&lt;/p&gt;\n&quot;]]]],[]],[[&quot;needsHandling&quot;,[null,735,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns true if this Collision needs to be resolved, such as by applying an impulse\nto reverse the velocities of the objects. This remains &lt;code&gt;true&lt;/code&gt; even after backing up in\ntime.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#needsHandling&quot;]],null,[]]],[]],[],null,[],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if this Collision needs to be resolved&lt;/p&gt;\n&quot;]]]],[]],[[&quot;setDetectedTime&quot;,[null,746,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Stores the time when this collision was detected, stores the current distance and\nvelocity as the detected distance and detected velocity, and estimates when the\ncollision occurred.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[],null,[[&quot;time&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;when this collision is detected&lt;/p&gt;\n&quot;]]]]],null,[[null,[null,null,null,[&quot;Error&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;if the detected time has been previously set&lt;/p&gt;\n&quot;]]]]]],[[&quot;setNeedsHandling&quot;,[null,768,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Mark this Collision as one that &lt;em&gt;needs handling&lt;/em&gt; because it is has caused the\ncollision engine to backup in time in order to resolve this Collision. This is useful\nbecause after backing up in time, a Collision may no longer report itself as\n&lt;a href=\&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html#isColliding\&quot;&gt;&lt;code&gt;#isColliding&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#setNeedsHandling&quot;]],null,[]]],[]],[],null,[[&quot;needsHandling&quot;,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if this Collision needs to be resolved&lt;/p&gt;\n&quot;]]]]],null,[]],[[&quot;similarTo&quot;,[null,779,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Returns whether this collision could be the same as another collision. Often there\nare several collisions found at a single location by the various collision detection\nmechanisms, and this is used when deciding which collision of those to keep.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[]],[],null,[[&quot;c&quot;,[null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBodyCollision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html&quot;]],null,[]]],[[[null,&quot;&lt;p&gt;the other collision&lt;/p&gt;\n&quot;]]]]],[null,[null,null,null,[&quot;boolean&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;true if the two collisions are possibly the same collision&lt;/p&gt;\n&quot;]]]],[]],[[&quot;toString&quot;,[null,376,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[]],null,null,null,null,null,[],[]],[],null,[],[null,[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[]],[[&quot;updateCollision&quot;,[null,801,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;Updates the information in the collision to reflect current position and velocity of\nbodies. Changes the impact point to be the nearest point between the bodies (as long as\nthis point is reasonably close to the original impact point). Then update the normal, R\nvectors, etc.&lt;/p&gt;\n&lt;p&gt;This is used when handling collisions because the collisions are\nfound post-collision, but are handled pre-collision.  Therefore, we\nneed to update the information to correspond to the pre-collision\narrangement of the bodies.&lt;/p&gt;\n&lt;p&gt;Doing this fixes inaccurate collisions;  for example, a ball that\nhits a wall at an angle would wrongly acquire spin if the collision\nwere not updated to the current pre-collision information.&lt;/p&gt;\n&lt;p&gt;Assumes that the bodies have been updated for their current location,\nby for example &lt;code&gt;myphysicslab.lab.engine2D.RigidBodySim#modifyObjects&lt;/code&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html#updateCollision&quot;]],null,[]]],[],[null,null,null,1]],[],null,[[&quot;time&quot;,[null,null,null,[&quot;number&quot;,null,null,1,[]]],[[[null,&quot;&lt;p&gt;the current simulation time&lt;/p&gt;\n&quot;]]]]],null,[]]],[[[&quot;ballNormal&quot;,[null,290,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;true if the normal object&amp;#39;s edge is curved&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;ballObject&quot;,[null,285,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;true if the &amp;#39;primary&amp;#39; object&amp;#39;s edge is curved&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;creator&quot;,[null,347,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;for debugging, unique code tells where this was generated&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;string&quot;,null,null,1,[]]]],[[&quot;distance&quot;,[null,306,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;distance between objects;  negative &amp;#61; penetration&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;distanceTol_&quot;,[null,242,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;distance tolerance is used to decide when bodies are touching.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,1]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;force&quot;,[null,372,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;amount of force applied at a contact point&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;impact1&quot;,[null,295,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;point of impact, in global coords&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]]],[[&quot;impact2&quot;,[null,301,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;second impact point needed for Rope because the impact points are far apart.\nOPTIONAL point of impact on normalBody, in global coords&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,null,1]]]]],[[&quot;impulse&quot;,[null,367,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;amount of impulse applied during collision&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;joint&quot;,[null,235,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;whether this is a bilateral constraint which can both push and pull&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;normal&quot;,[null,316,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;normal pointing outward from normalObj, in world coords&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]]],[[&quot;normalBody&quot;,[null,230,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;object corresponding to the normal (its edge defines the normal vector)&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBody&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBody.html&quot;]],null,[]]]],[[&quot;normalFixed&quot;,[null,275,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;true &amp;#61; normal is constant&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;boolean&quot;,null,null,1,[]]]],[[&quot;normal_dt&quot;,[null,321,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;derivative of normal vector with respect to time&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,null,null,[[[null,null,null,[&quot;myphysicslab.lab.util.Vector&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.util.Vector.html&quot;]],null,[]]],[null,null,null,null,null,null,null,null,null,1]]]]],[[&quot;primaryBody&quot;,[null,225,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;&amp;#39;primary&amp;#39; object whose corner or edge is colliding&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;myphysicslab.lab.engine2D.RigidBody&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBody.html&quot;]],null,[]]]],[[&quot;radius1&quot;,[null,326,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;radius of curvature at impact1, for primary body; negative means concave&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;radius2&quot;,[null,331,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;radius of curvature at impact1, for normal body; negative means concave&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,null,null,1]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]],[[&quot;velocityTol_&quot;,[null,265,null,[null,null,&quot;source/src/lab/engine2D/RigidBodyCollision.js.src.html&quot;]],[[[null,&quot;&lt;p&gt;velocity tolerance used to determine if an object is in contact with another\nobject. See &lt;code&gt;myphysicslab.lab.engine2D.ImpulseSim#getVelocityTol&lt;/code&gt;.&lt;/p&gt;\n&quot;]]],null,null,null,null,null,[],[],[null,1]],[null,null,null,[&quot;number&quot;,null,null,1,[]]]]],null,[],[[&quot;myphysicslab.lab.model.Collision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.model.Collision.html&quot;]],null,[]]],[],[[&quot;myphysicslab.lab.engine2D.RigidBodyCollision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html&quot;]],null,[]],null,1],null,&quot;myphysicslab.lab.engine2D.RigidBodyCollision.html&quot;,&quot;myphysicslab.lab.engine2D.RigidBodyCollision&quot;,[],[[&quot;myphysicslab.lab.engine2D.ConnectorCollision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.ConnectorCollision.html&quot;]],null,[]],[&quot;myphysicslab.lab.engine2D.CornerCornerCollision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.CornerCornerCollision.html&quot;]],null,[]],[&quot;myphysicslab.lab.engine2D.CornerEdgeCollision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.CornerEdgeCollision.html&quot;]],null,[]],[&quot;myphysicslab.lab.engine2D.EdgeEdgeCollision&quot;,null,[null,null,[null,null,&quot;myphysicslab.lab.engine2D.EdgeEdgeCollision.html&quot;]],null,[]]],[],[]]]]]"></main><footer><div><a href="https://github.com/jleyba/js-dossier">Generated by dossier</a></div></footer></div><script src="dossier.js" defer></script>